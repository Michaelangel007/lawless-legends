///////////////////////////////////////////////////////////////////////////////////////////////////
// Handy constants.
const FALSE = 0
const TRUE  = !FALSE
const NULL  = 0

///////////////////////////////////////////////////////////////////////////////////////////////////
// Fixed memory locations
const raycaster  = $6000   // main mem
const tileEngine = $6000   // main mem
const expandVec  = $2000   // aux mem
const fontEngine = $BA00   // main mem

///////////////////////////////////////////////////////////////////////////////////////////////////
// Resource numbers
const RES_NUM_RAYCASTER   = 1
const RES_NUM_EXPAND_VEC  = 2
const RES_NUM_FONT_ENGINE = 3
const RES_NUM_TILE_ENGINE = 4

///////////////////////////////////////////////////////////////////////////////////////////////////
// Hardware addresses.
const keyboard  = $C000
const keystrobe = $C010

///////////////////////////////////////////////////////////////////////////////////////////////////
// Memory manager definitions

// Resource types
const RES_TYPE_CODE     = 1
const RES_TYPE_2D_MAP   = 2
const RES_TYPE_3D_MAP   = 3
const RES_TYPE_TILE     = 4
const RES_TYPE_TEXTURE  = 5
const RES_TYPE_SCREEN   = 6
const RES_TYPE_FONT     = 7
const RES_TYPE_MODULE   = 8
const RES_TYPE_BYTECODE = 9
const RES_TYPE_FIXUP    = 10

// Memory banks
const MAIN_MEM = 0
const AUX_MEM  = 1

// Command codes
const RESET_MEMORY   = $10
const REQUEST_MEMORY = $11
const LOCK_MEMORY    = $12
const UNLOCK_MEMORY  = $13
const SET_MEM_TARGET = $14
const START_LOAD     = $15
const QUEUE_LOAD     = $16
const FINISH_LOAD    = $17
const FREE_MEMORY    = $18
const CALC_FREE      = $19
const DEBUG_MEM      = $1A
const CHAIN_LOADER   = $1E
const FATAL_ERROR    = $1F

///////////////////////////////////////////////////////////////////////////////////////////////////
// Other constants
const callbacks = $300
const MAX_LOC_TRIG = 128

// 3D mode
//const OVERMAP_NUM = 11
//const OVERMAP_IS_3D = 1
// 2D mode
const OVERMAP_NUM = 1
const OVERMAP_IS_3D = 0

///////////////////////////////////////////////////////////////////////////////////////////////////
// Predefined functions, for circular calls or out-of-order calls
predef moveBackward, setWindow2, initCmds2D, initCmds3D

///////////////////////////////////////////////////////////////////////////////////////////////////
// Raycaster variables
const playerDir = $5D
const playerX   = $5E
const playerY   = $60
const backBuf   = $6A
const frontBuf  = $6B

///////////////////////////////////////////////////////////////////////////////////////////////////
// Tile engine variables
const relX      = $50
const relY      = $51
const avatarTile= $9D   // the avatar variables are set by tile engine during its draw phase
const avatarX   = $9E
const avatarY   = $9F

///////////////////////////////////////////////////////////////////////////////////////////////////
// Font engine variables
const wndleft   = $70  // left edge of the window
const wndwdth   = $71  // right edge (NOT width) of text window
const wndtop    = $72  // top of text window
const wndbtm    = $73  // bottom+1 of text window
const cursh     = $74  // Cursor H-pos 0-39
const cursv     = $75  // Cursor V-pos 0-23

///////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
byte mapNum = OVERMAP_NUM
byte mapIs3D = OVERMAP_IS_3D
word pFont
word pMap
word pScripts
word cmdTbl[64]
word triggerTbl
byte prevX
byte prevY
byte prevMapNum
byte prevMapIs3D
byte redraw
byte titleLoaded = FALSE
byte cacheSky, cacheGround
word cacheX, cacheY
byte cacheDir
byte resetLocFromCache = FALSE
byte textDrawn = FALSE

// Movement amounts when walking at each angle
// Each entry consists of an X bump and a Y bump, in 8.8 fixed point
word walkDirs[] = $0040, $0000
word            = $003B, $0018
word            = $002D, $002D
word            = $0018, $003B
word            = $0000, $0040
word            = $FFE8, $003B
word            = $FFD3, $002D
word            = $FFC5, $0018
word            = $FFC0, $0000
word            = $FFC5, $FFE8
word            = $FFD3, $FFD3
word            = $FFE8, $FFC5
word            = $0000, $FFC0
word            = $0018, $FFC5
word            = $002D, $FFD3
word            = $003B, $FFE8

byte skyGndTbl1[] = $00 // lo-bit black
byte              = $00 // lo-bit black
byte              = $00 // lo-bit black
byte              = $02 // violet
byte              = $08 // green
byte              = $0A // lo-bit white
byte              = $0A // lo-bit white
byte              = $0A // lo-bit white
byte              = $20 // hi-bit black
byte              = $20 // hi-bit black
byte              = $20 // hi-bit black
byte              = $22 // blue
byte              = $28 // orange
byte              = $2A // hi-bit white
byte              = $2A // hi-bit white
byte              = $2A // hi-bit white
byte skyGndTbl2[] = $00 // lo-bit black
byte              = $02 // violet
byte              = $08 // green
byte              = $02 // violet
byte              = $08 // green
byte              = $02 // violet
byte              = $08 // green
byte              = $0A // lo-bit white
byte              = $20 // hi-bit black
byte              = $22 // blue
byte              = $28 // orange
byte              = $22 // blue
byte              = $28 // orange
byte              = $22 // blue
byte              = $28 // orange
byte              = $2A // hi-bit white

word skyNum = 9
word groundNum = 10

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm __defs

; Use hi-bit ASCII for Apple II
!convtab "../../include/hiBitAscii.ct"

; Headers
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
!source "../../include/fontEngine.i"

; Optional debug printing support
DEBUG   = 1
!if DEBUG { !source "../../include/debug.i" }

; General use
tmp         = $2
pTmp        = $4

; Variables that get set by the tile engine when it draws
avatarTile  = $9D
avatarX     = $9E   ; from the tile engine
avatarY     = $9F   ; ...ditto

end
        
///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a string
asm puts
        txa
        pha
        bit setROM
        lda evalStkL,x
        sta pTmp
        lda evalStkH,x
        sta pTmp+1
        ldy #0
        lda (pTmp),y
        tax
        iny
-       lda (pTmp),y
        ora #$80
        jsr cout
        iny
        dex
        bne -
        bit setLcRW+lcBank2
        pla
        tax
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print part of a string, until we hit the end or a '%' code. Return how far we got, or -1 for end.
asm partialPrintf
        bit setROM
        lda evalStkL+1,x
        sta pTmp
        lda evalStkH+1,x
        sta pTmp+1
        ldy #0
        lda (pTmp),y        ; get length byte
        sec
        sbc evalStkL,x      ; minus offset
        sta tmp             ; to count of characters left to print
        lda evalStkL,x      ; get desired offset into string
        tay
        iny                 ; increment past length byte
        inx                 ; drop second argument
        lda #0
        sta evalStkH,x      ; clear out high byte of return value
-       lda (pTmp),y
        ora #$80
        cmp #'%'            ; stop if we hit % code
        beq +
        jsr cout
        iny
        dec tmp             ; otherwise go until end of string
        bne -
        ldy #0              ; if we hit end of string, return val will be $FF
        dec evalStkH,x      ; hi byte $FF as well
+       dey                 ; adjust back for length byte
        tya
        sta evalStkL,x      ; tell caller how far we got
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a 16-bit hex value
asm printHex
        bit setROM
        lda evalStkH,x
        jsr prbyte
        lda evalStkL,x
        jsr prbyte
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a single character
asm printChar
        bit setROM
        lda evalStkL,x
        ora #$80
        jsr cout
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a carriage return
asm crout
        bit setROM
        jsr crout
        dex                   ; don't-care return value
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Ring the bell
asm beep
        bit setROM
        jsr bell
        dex                   ; don't-care return value
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Send a command to the memory manager
// Params: cmd, mainOrAux, amount
asm loader
        txa
        pha
        bit setROM
        lda evalStkL+2,x        ; command code
        pha
        lda evalStkL+1,x        ; main or aux
        lsr
        ldy evalStkH,x          ; address (or other param)
        lda evalStkL,x
        tax
        pla
        bcs +
        jsr mainLoader
        clc
        bcc ++
+       jsr auxLoader
++      stx tmp
        pla
        tax
        inx                     ; drop second and third parameters
        inx
        lda tmp
        sta evalStkL,x
        tya
        sta evalStkH,x
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set up the font engine
// Params: pFont
asm initFontEngine
        txa
        pha
        bit setROM
        ldy evalStkL,x   ; font engine likes *lo* byte in Y
        lda evalStkH,x   ; hi byte in X
        tax
        jsr setFONT
        ; Set to write text on both hi-res pages at the same time
        lda #pHGR3
        jsr displayMODE
        ; Set to normal (non-inverse) text
        lda #pNORMAL
        jsr drawMODE
        pla
        tax
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set up the ray casting engine or tile engine (they share the same address)
// Params: pMap
asm initDisplayEngine
        txa
        pha
        bit setROM
        lda evalStkL,x
        ldy evalStkH,x
        jsr $6000
        pla
        tax
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Render one frame using the ray caster or tile engine (they share the same address)
// Params: none
asm renderFrame
        txa
        pha
        bit setROM
        jsr $6003
        pla
        tax
        dex                 ; don't-care return value
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Deal with crossing into a new map section
// Params: none
asm checkCrossing
        txa
        pha
        bit setROM
        jsr $6006
        pla
        tax
        dex                 ; don't-care return value
        bit setLcRW+lcBank2
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set either the sky or ground color
// Params: (index<<8) | (colorCode)
asm setColor
        txa
        pha
        bit setROM
        lda evalStkL,x
        ldy evalStkH,x
        jsr $600C
        bit setLcRW+lcBank2
        pla
        tax
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Jump straight to the system monitor
// Params: None
asm goMon
        bit setROM
        jmp $FF69
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Jump straight to the system monitor
// Params: None
asm brk
        bit setROM
        brk
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Use the font engine to clear the current text window
// Params: None
asm clearWindow
        bit setROM
        txa
        pha
        jsr clearWINDOW
        bit setLcRW+lcBank2
        pla
        tax
        dex                   ; don't-care return value
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display a string using the font engine. Automatically splits lines to keep words from breaking.
// Params: pStr
asm displayStr
    bit setROM
    txa
    pha
    lda evalStkL,x
    sta pTmp
    lda evalStkH,x
    sta pTmp+1
    ldy #0
    lda (pTmp),y
    beq ++
    inc pTmp
    bne +
    inc pTmp+1
+
--  tax
    ldy #0
-   lda (pTmp),y
    cmp #$20
    bcc +
    cmp #$80
    bcc ++
+   lda #$C4
    jsr $fded
    brk
++  dex
    cmp #$20
    beq +
    sta $281,y
    iny
    cpx #0    
    bne -
+   sty $280
    tya
    sec
    adc pTmp
    sta pTmp
    bcc +
    inc pTmp+1
+   txa
    pha
    tya
    clc
    adc cursh
    sec
    sbc #2
    cmp wndwdth
    bcc +
    lda #$D
    jsr printCHAR
+   ldy #$80
    ldx #2
    jsr printSTR
    lda cursh
    cmp wndleft
    beq +
    lda #$20
    jsr printCHAR
+   pla
    bne --
++  lda #$d
    jsr printCHAR
    bit setLcRW+lcBank2
    pla
    tax
    rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Convert a PLASMA string (starts with length, lo-bit ascii) to an assembly string
// (zero-terminated, hi-bit ascii).
asm toAsmStr
  lda evalStkL,x
  sta pTmp
  lda evalStkH,x
  sta pTmp+1
  ldy #0
  lda (pTmp),y
  beq +
  sta tmp
- iny
  lda (pTmp),y
  ora #$80
  dey
  sta (pTmp),y
  iny
  dec tmp
  bne -
  lda #0
  sta (pTmp),y
+ rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// General methods

///////////////////////////////////////////////////////////////////////////////////////////////////
// Fatal error: print message and stop the system.
def fatal(msg)
  toAsmStr(msg)
  loader(FATAL_ERROR, MAIN_MEM, msg)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a formatted string a'la C printf, with up to four parameters.
def printf2(str, arg1, arg2)
  word pos
  word curArg
  word p
  pos = 0
  curArg = @arg1
  while TRUE
    pos = partialPrintf(str, pos)
    if pos < 0
      break
    fin
    p = str + pos + 2
    when ^p
      is 'x'
        printHex(*curArg)
        break
      is '%'
        printChar('%')
        break
      otherwise
        printHex(^p)
        fatal("Unknown % code")
    wend
    curArg = curArg + 2
    pos = pos + 2
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Get a keystroke and convert it to upper case
def getUpperKey()
  byte key
  while ^keyboard < 128
  loop
  key = ^keyboard & $7F
  ^keystrobe
  if key >= $60
    key = key - $20
  fin
  return key
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Is the player's current position a physical obstruction?
def isBlocked()
  return ^avatarTile & $40
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Is there a script attached to the player's current position?
def isScripted()
  return ^avatarTile & $20
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set the sky color (relevant to 3D display only)
def setSky(num)
  skyNum = num
  setColor(0<<8 | skyGndTbl1[skyNum])
  setColor(1<<8 | skyGndTbl2[skyNum])
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to the next sky color (3D only)
def nextSky()
  setSky((skyNum + 1) & $F)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set the ground color (relevant to 3D display only)
def setGround(num)
  groundNum = num
  setColor(2<<8 | skyGndTbl1[groundNum])
  setColor(3<<8 | skyGndTbl2[groundNum])
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to the next ground color
def nextGround()
  setGround((groundNum + 1) & $F)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to text mode and display mem manager debug printout, get a key, switch back to graphics.
def debugMem(bank)
  ^$c051
  ^$c054
  loader(DEBUG_MEM, bank, 0)
  getUpperKey()
  ^$c050
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Clear the command table
def resetCmds()
  byte i
  for i = 0 to 63
    cmdTbl[i] = 0
  next
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Establish a keystroke -> command association in the command table
def initCmd(key, func)
  if key >= $60
    key = key - $20
  fin
  cmdTbl[key-$20] = func
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load the Frame Image, and lock it.
def loadFrameImg()
  byte img
  if titleLoaded
    loader(UNLOCK_MEMORY,MAIN_MEM, $2000)
    loader(FREE_MEMORY,  MAIN_MEM, $2000)
    titleLoaded = FALSE
  fin
  loader(SET_MEM_TARGET, MAIN_MEM, $2000)
  loader(QUEUE_LOAD,     MAIN_MEM, (3-mapIs3D)<<8 | RES_TYPE_SCREEN)
  loader(LOCK_MEMORY,    MAIN_MEM, $2000)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load code and data, set up everything to display a 3D map
def initMap3D()
  word scriptModule

  // Set up the command table
  initCmds3D()

  // Reset memory (our module will stay since memory manager locked it upon load)
  loader(RESET_MEMORY, MAIN_MEM, 0)

  // Load the font engine
  loader(SET_MEM_TARGET, MAIN_MEM, fontEngine)
  loader(QUEUE_LOAD,     MAIN_MEM, RES_NUM_FONT_ENGINE<<8 | RES_TYPE_CODE)

  // Load the font for the font engine
  loader(SET_MEM_TARGET, MAIN_MEM, $9000)
  pFont = loader(QUEUE_LOAD, MAIN_MEM, 1<<8 | RES_TYPE_FONT)

  // Load the raycaster
  loader(SET_MEM_TARGET, MAIN_MEM, raycaster)
  loader(QUEUE_LOAD,     MAIN_MEM, RES_NUM_RAYCASTER<<8 | RES_TYPE_CODE)

  // Load the texture expansion code
  loader(SET_MEM_TARGET, AUX_MEM, expandVec)
  loader(QUEUE_LOAD,     AUX_MEM, RES_NUM_EXPAND_VEC<<8 | RES_TYPE_CODE)

  // Load the map
  pMap = loader(QUEUE_LOAD, MAIN_MEM, mapNum<<8 | RES_TYPE_3D_MAP)

  // Load everything that we just queued
  loader(FINISH_LOAD, MAIN_MEM, 1) // 1 = keep open

  // Load the frame image (and lock it there)
  loadFrameImg()

  // Load the scripts for this map, if it has any.
  scriptModule = pMap->2  // first 2 bytes are width and height, third byte is script module num
  if scriptModule
    pScripts = loader(QUEUE_LOAD, MAIN_MEM, (scriptModule << 8) | RES_TYPE_MODULE)
  fin
  loader(FINISH_LOAD, MAIN_MEM, 0) // 1 = keep open, for loading textures

  // Start up the font engine
  initFontEngine(pFont)

  // Start up the raycaster
  initDisplayEngine(pMap)

  // Set initial player position in case the init script doesn't do it
  ^playerDir = 1
  *playerX = $280
  *playerY = $380

  // Initialize the map scripts
  setWindow2()
  clearWindow()
  textDrawn = FALSE

  prevX = -1
  prevY = -1
  triggerTbl = NULL
  prevMapNum = mapNum
  prevMapIs3D = mapIs3D
  if pScripts
    *pScripts()
  fin

  // If we're returning to a map, resume from where the player left off
  if resetLocFromCache
    *playerX = cacheX
    *playerY = cacheY
    ^playerDir = cacheDir
    prevX = playerX.1 - 1
    prevY = playerY.1 - 1
    setSky(cacheSky)
    setGround(cacheGround)
    resetLocFromCache = FALSE
  fin
  
  // Draw the first frame
  renderFrame()
  redraw = FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load code and data, set up everything to display a 2D map
def initMap2D()
  word scriptModule

  // Set up the command table
  initCmds2D()

  // Reset memory (our module will stay since memory manager locked it upon load)
  loader(RESET_MEMORY, MAIN_MEM, 0)

  // Load the font engine
  loader(SET_MEM_TARGET, MAIN_MEM, fontEngine)
  loader(QUEUE_LOAD,     MAIN_MEM, RES_NUM_FONT_ENGINE<<8 | RES_TYPE_CODE)

  // Load the font for the font engine
  loader(SET_MEM_TARGET, MAIN_MEM, $9000)
  pFont = loader(QUEUE_LOAD, MAIN_MEM, 1<<8 | RES_TYPE_FONT)

  // Load the tile engine
  loader(SET_MEM_TARGET, MAIN_MEM, tileEngine)
  loader(QUEUE_LOAD,     MAIN_MEM, RES_NUM_TILE_ENGINE<<8 | RES_TYPE_CODE)

  // Load everything that we just queued
  loader(FINISH_LOAD, MAIN_MEM, 1) // 1 = keep open

  // Load the frame image (and lock it there)
  loadFrameImg()

  // Start up the font engine
  initFontEngine(pFont)

  // For now
  prevX = -1
  prevY = -1
  triggerTbl = NULL
  prevMapNum = mapNum
  prevMapIs3D = mapIs3D

  // Start up the tile engine
  initDisplayEngine(mapNum)

  // And do the first draw.
  renderFrame()
  redraw = FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set up mapNum (2D or 3D depending on state of is3DMap)
def initMap()
  if mapIs3D
    initMap3D()
  else
    initMap2D()
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Window for the map name bar
def setWindow1()
  ^wndtop = 1
  ^wndbtm = 2
  ^wndleft = 4
  ^wndwdth = 18
  ^cursv = ^wndtop
  ^cursh = ^wndleft
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Window for the large upper right bar
def setWindow2()
  ^wndtop = 3
  ^wndbtm = 17
  ^wndleft = 22
  ^wndwdth = 37
  ^cursv = ^wndtop
  ^cursh = ^wndleft
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Window for the mid-size lower right bar
def setWindow3()
  ^wndtop = 18
  ^wndbtm = 23
  ^wndleft = 23
  ^wndwdth = 37
  ^cursv = ^wndtop
  ^cursh = ^wndleft
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Make sure page 1 of hi-res is displayed. Do this before doing memory manager operations, since
// they overwrite page 2.
def flipToFirstPage
  if ^frontBuf == 1
    renderFrame()
    redraw = FALSE
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def callScripts(x, y)
  word p
  word pNext
  word script

  p = triggerTbl
  while TRUE
    if ^p == $FF
      return
    fin
    pNext = p + p->1
    if ^p == y
      p = p + 2
      while p < pNext
        if x == ^p
          script = p=>1
          script()
        fin
        p = p + 3
      loop
    fin
    p = pNext
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Check for script(s) attached to the current location, and call them if there are any.
def checkScripts()
  word x
  word y
  if !triggerTbl
    return
  fin
  if mapIs3D
    x = playerX.1 - 1
    y = playerY.1 - 1
  else
    x = ^avatarX
    y = ^avatarY
  fin
  if x <> prevX or y <> prevY
    prevX = x
    prevY = y
    if textDrawn
      clearWindow()
      textDrawn = FALSE
    fin
    if isScripted()
      callScripts(x, y)
    fin
  fin
  if (mapNum <> prevMapNum) or (mapIs3D <> prevMapIs3D)
    flipToFirstPage()
    initMap()
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Advance one step forward (3D maps only)
def moveForward()
  word wasBlocked 
  word func
  wasBlocked = isBlocked()
  *playerX = *playerX + walkDirs[^playerDir << 1]
  *playerY = *playerY + walkDirs[(^playerDir << 1) + 1]
  if !wasBlocked and isBlocked()
    moveBackward()
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Adjust player's direction plus or minus n increments (3D mode)
def adjustDir(n)
  ^playerDir = (^playerDir + n) & $F
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Move backward one step (3D mode)
def moveBackward()
  adjustDir(8)
  moveForward()
  adjustDir(8)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Turn left (3D mode)
def rotateLeft()
  adjustDir(-1)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Rotate to the right (3D mode)
def rotateRight()
  adjustDir(1)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Sidestep to the right (3D mode)
def strafeRight()
  adjustDir(4)
  moveForward()
  adjustDir(-4)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Sidestep to the left (3D mode)
def strafeLeft()
  adjustDir(-4)
  moveForward()
  adjustDir(4)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def move2D(ox, oy)
  *relX = ox + *relX
  *relY = oy + *relY
  checkCrossing()
  redraw = TRUE
end

def moveNorth()
  move2D(0, -1)
end

def moveEast()
  move2D(1, 0)
end

def moveSouth()
  move2D(0, 1)
end

def moveWest()
  move2D(-1, 0)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to a new map (2D or 3D)
def setMap(is3D, num)
  // save player state if we're coming *from* the over-map
  if mapNum == OVERMAP_NUM and mapIs3D == OVERMAP_IS_3D
    cacheX = *playerX
    cacheY = *playerY
    cacheDir = ^playerDir
    cacheSky = skyNum
    cacheGround = groundNum
  else
    resetLocFromCache = TRUE
  fin
  mapIs3D = is3D
  mapNum = num
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to next map in the current 2D or 3D mode.
def nextMap()
  mapNum = mapNum + 1
  if mapNum > 20
    mapNum = 1
  fin
  setMap(mapIs3D, mapNum)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Jump to a new map location (and in 3D mode, point in the given direction)
def teleport(x, y, dir)
  *playerX = ((x+1)<<8) | $80
  *playerY = ((y+1)<<8) | $80
  prevX = x
  prevY = y
  clearWindow()
  textDrawn = FALSE
  ^playerDir = dir
  redraw = TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Get a key and dispatch it to a command. Then do it again, forever.
def kbdLoop()
  word key, func
  while TRUE
    key = getUpperKey()
    key = key - $20
    if key >= 0 and key < $40
      func = cmdTbl[key]
      if func
        func()
        renderFrame()
        redraw = FALSE
        checkScripts()
        if redraw
          renderFrame()
          redraw = FALSE
        fin
      fin
    fin
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Associate a location with a trigger function (i.e. a script)
def setLocationTrigger(tbl)
  triggerTbl = tbl
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Called by scripts to display a string. We set the flag noting that something has been
// displayed, then use an assembly routine to do the work.
def scriptDisplayStr(str)
  textDrawn = TRUE
  displayStr(str)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Get a key, and don't return until it's Y or N (or lower-case of those). Returns 1 for Y.
def getYN()
  byte key
  while TRUE
    key = getUpperKey()
    if key == 'Y'
      return 1
    elsif key == 'N'
      clearWindow()
      textDrawn = FALSE
      return 0
    fin
    beep()
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set up the command table for 3D mode
def initCmds3D()
  resetCmds()

  initCmd('W', @moveForward)
  initCmd('A', @rotateLeft)
  initCmd('D', @rotateRight)
  initCmd('S', @moveBackward)
  initCmd('X', @moveBackward)
  initCmd('Z', @strafeLeft)
  initCmd('C', @strafeRight)

  initCmd('I', @moveForward)
  initCmd('J', @rotateLeft)
  initCmd('L', @rotateRight)
  initCmd('K', @moveBackward)
  initCmd(',', @moveBackward)
  initCmd('M', @strafeLeft)
  initCmd('.', @strafeRight)

  initCmd('N', @nextMap)

  initCmd('Y', @nextSky)
  initCmd('G', @nextGround)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set up the command table for 2D mode
def initCmds2D()
  resetCmds()

  initCmd('W', @moveNorth)
  initCmd('D', @moveEast)
  initCmd('S', @moveSouth)
  initCmd('X', @moveSouth)
  initCmd('A', @moveWest)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load and display the title screen.
def loadTitle()
  puts("Loading Lawless Legends.\n")
  printf2("Test %x and %x...\n", $1001, $2002)

  // Load the title screen
  puts("Loading title screen.\n")
  loader(SET_MEM_TARGET, MAIN_MEM, $2000)
  loader(QUEUE_LOAD,     MAIN_MEM, 1<<8 | RES_TYPE_SCREEN)  // title screen is fixed at #1
  loader(LOCK_MEMORY,    MAIN_MEM, $2000)
  loader(FINISH_LOAD, MAIN_MEM, 1) // 1 = keep open
  titleLoaded = TRUE
  puts("Title loaded.\n")
  ^$c050
  ^$c057
  ^$c054
  ^$c052
  // Hack for real (not emulated) IIc: sometimes displays only lo-bit graphics
  // unless we do this. *HUGE* thanks to Brendan Robert for the fix!
  ^$C07E=0   // disable double-hi-res
  ^$C05F     // disable double-hi-res
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set vectors so that scripts in PLASMA can call back to do things with this engine.
def setCallbacks()

  // $300
  callbacks.0 = $4c
  callbacks:1 = @setLocationTrigger

  // $303
  callbacks.3 = $4c
  callbacks:4 = @scriptDisplayStr

  // $306
  callbacks.6 = $4c
  callbacks:7 = @getYN

  // $309
  callbacks.9 = $4c
  callbacks:10 = @setMap

  // $30C
  callbacks.12 = $4c
  callbacks:13 = @setSky

  // $30F
  callbacks.15 = $4c
  callbacks:16 = @setGround

  // $312
  callbacks.18 = $4c
  callbacks:19 = @teleport
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Main code.
//
loadTitle()
setCallbacks()
initMap()
setWindow2()
kbdLoop()

done