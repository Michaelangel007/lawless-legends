const iobuffer    = $0800
const databuff    = $0C00
const MODADDR     = $1000

predef home, gotoxy, viewport, crout, cout, prstr, cin, rdstr
predef syscall, romcall
predef markheap, allocheap, releaseheap, availheap
predef memclr, memset, memcpy
predef uword_isgt, uword_isge, uword_islt, uword_isle
predef getpfx, setpfx, newline, online, open, close, read, write, create, destroy
byte version[]    = "PLASMA VERSION 0.9"
byte errorstr[]   = "ERROR: $"
byte okstr[]      = "OK"
byte heaperr[]    = "ERR: HEAP/FRAME COLLISION.\n"
byte prefix[32]   = ""
byte readerrstr   = "ERROR READING FILE"
byte davestr[]    = "Relocateble PLASMA module:"
byte modsizestr[] = "Module size: $"
byte modlenstr[]  = "Module len:  $"
byte modcodestr[] = "Module code: $"
byte modinitstr[] = "Module init: $"
byte adddefstr[]  = "Add def call: $"
byte defstr[]     = "DEF        "
byte externstr[]  = "EXTERN[$"
byte internstr[]  = "INTERN     "
byte wordstr[]    = " WORD"
byte bytestr[]    = " BYTE"
byte addrstr[]    = "@$"
byte luerrstr[]   = "Lookup fail: "
byte stdlibstr[]  = "STDLIB"
byte clsstr[]     = "CLS"
byte gotoxystr[]  = "GOTOXY"
byte viewstr[]    = "VIEWPORT"
byte putnlstr[]   = "PUTNL"
byte putcstr[]    = "PUTC"
byte putsstr[]    = "PUTS"
byte getcstr[]    = "GETC"
byte getsstr[]    = "GETS"
byte sysstr[]     = "SYSCALL"
byte romstr[]     = "ROMCALL"
byte getpfxstr[]  = "GETPREFIX"
byte setpfxstr[]  = "SETPREFIX"
byte newlinestr[] = "SETNEWLINE"
byte onlinestr[]  = "ONLINE"
byte openstr[]    = "OPEN"
byte closestr[]   = "CLOSE"
byte readstr[]    = "READ"
byte writestr[]   = "WRITE"
byte creatstr[]   = "CREATE"
byte destroystr[] = "DESTROY"
byte hpmarkstr[]  = "HEAPMARK"
byte hpallocstr[] = "HEAPALLOC"
byte hprelstr[]   = "HEAPRELEASE"
byte hpavailstr[] = "HEAPAVAIL"
byte memclrstr[]  = "MEMCLR"
byte memsetstr[]  = "MEMSET"
byte memcpystr[]  = "MEMCPY"
byte uisgtstr[]   = "ISUGT"
byte uisgestr[]   = "ISUGE"
byte uisltstr[]   = "ISULT"
byte uislestr[]   = "ISULE"
word exports[]    = @clsstr,    @home
word              = @gotoxystr, @gotoxy
word		  = @viewstr,   @viewport
word		  = @putnlstr,  @crout
word		  = @putcstr,   @cout
word		  = @putsstr,   @prstr
word		  = @getcstr,   @cin
word		  = @getsstr,   @rdstr
word		  = @sysstr,    @syscall
word		  = @romstr,    @romcall
word		  = @hpmarkstr, @markheap
word		  = @hpallocstr,@allocheap
word		  = @hprelstr,  @releaseheap
word		  = @hpavailstr,@availheap
word		  = @memclrstr, @memclr
word		  = @memsetstr, @memset
word		  = @memcpystr, @memcpy
word              = @uisgtstr,  @uword_isgt
word              = @uisgestr,  @uword_isge
word              = @uisltstr,  @uword_islt
word              = @uislestr,  @uword_isle
word              = @getpfxstr, @getpfx
word		  = @setpfxstr, @setpfx
word		  = @newlinestr,@newline
word		  = @onlinestr, @online
word		  = @openstr,   @open
word              = @closestr,  @close
word		  = @readstr,   @read
word		  = @writestr,  @write
word		  = @creatstr,  @create
word		  = @destroystr,@destroy
word              = 0
word heap         = $6000
byte modtbl[256]
word lastmod      = @modtbl
byte symtbl[1024]
word lastsym      = @symtbl
byte deftbl[2048]
word lastdef      = @deftbl
word perr
word cmdptr
;
; Utility functions
;
asm equates
;*
;* BANK SWITCHED MEM
;*
LCRDEN 	=	$C080
LCWTEN	=	$C081
ROMEN	=	$C082
LCRWEN 	=	$C083
LCBNK2	=	$00
LCBNK1	=	$08
	!SOURCE	"plvm02zp.inc"
;*
;* ASM VARIABLES
;*
ESP	!BYTE	0
end
;
; CALL 6502 ROUTINE
; ROMCALL(AREG, XREG, YREG, STATUS, ADDR)
;
asm romcall
        PHP
        LDA     ESTKL,X
        STA     TMPL
        LDA     ESTKH,X
        STA     TMPH
        INX
        LDA     ESTKL,X
        PHA
        INX
        LDA     ESTKL,X
        TAY
        INX
        LDA     ESTKL+1,X
        PHA
        LDA     ESTKL,X
        INX
        STX     ESP
        TAX
        PLA
        BIT     ROMEN
        PLP
        JSR     JMPTMP
        PHP
        BIT     LCRDEN+LCBNK2
        STA     REGVALS+0
        STX     REGVALS+1
        STY     REGVALS+2
        PLA
        STA     REGVALS+3
        LDX     ESP
        LDA     #<REGVALS
        LDY     #>REGVALS
        STA     ESTKL,X
        STY     ESTKH,X
        PLP
        RTS
REGVALS !FILL	4
JMPTMP	JMP	(TMP)
end
;
; CALL PRODOS
; SYSCALL(CMD, PARAMS)
;
asm syscall
	LDA	ESTKL,X
	LDY	ESTKH,X
	STA	PARAMS
	STY	PARAMS+1
	INX
	LDA	ESTKL,X
	STA	CMD
	STX	ESP
	JSR	$BF00
CMD:	!BYTE	00
PARAMS:	!WORD	0000
	LDX	ESP
	STA	ESTKL,X
	LDY    	#$00
	STY	ESTKH,X
	RTS
end
;
; CALL LOADED SYSTEM PROGRAM
;
asm exec
	LDA	#$00
	STA	IFPL
	LDA	#$BF
	STA	IFPH
	LDX	#$FF
	TXS
	LDX	#ESTKSZ/2
	BIT	ROMEN
	JMP	$2000
end
;
; EXIT
;
asm reboot
	BIT	ROMEN
	LDA	#$00
	STA	$3F4		; INVALIDATE POWER-UP BYTE
	JMP	($FFFC)		; RESET
end
;
; SET MEMORY TO 0
; MEMCLR(ADDR, SIZE)
;
asm memclr
	LDY	#$00
	LDA 	ESTKL+1,X
	STA 	DSTL
	LDA 	ESTKH+1,X
	STA 	DSTH
	INC	ESTKL,X
	INC 	ESTKH,X
	TYA
CLRMLP 	DEC 	ESTKL,X
	BNE	+
	DEC	ESTKH,X
	BEQ	++
+	STA	(DST),Y
	INY
	BNE	CLRMLP
	INC	DSTH
	BNE	CLRMLP
++	INX
	RTS
end
;
; SET MEMORY TO VALUE
; MEMSET(ADDR, SIZE, VALUE)
;
asm memset
	LDY     #$00
	LDA     ESTKL+2,X
	STA     DSTL
	LDA     ESTKH+2,X
	STA     DSTH
	INC     ESTKL+1,X
	INC     ESTKH+1,X
SETMLP	DEC     ESTKL+1,X
	BNE     +
	DEC     ESTKH+1,X
	BEQ     SETMEX
+	LDA     ESTKL,X
	STA     (DST),Y
	INY
	BNE     +
	INC     DSTH
+	DEC     ESTKL+1,X
	BNE     +
	DEC     ESTKH+1,X
	BEQ     SETMEX
+	LDA     ESTKH,X
	STA     (DST),Y
	INY
	BNE     SETMLP
	INC     DSTH
	BNE     SETMLP
SETMEX	INX
	INX
	RTS
end
;
; COPY MEMORY
; MEMCPY(DSTADDR, SRCADDR, SIZE)
;
asm memcpy
	LDY	#$00
	LDA	ESTKL,X
	BNE 	+
	LDA	ESTKH,X
	BEQ	CPYMEX
+	LDA	ESTKL+2,X
	STA 	DSTL
	LDA	ESTKH+2,X
	STA 	DSTH
	LDA	ESTKL+1,X
	STA 	SRCL
	LDA	ESTKH+1,X
	STA 	SRCH
	CMP	DSTH
	BCC	REVCPY
	BNE	FORCPY
	LDA 	SRCL
	CMP	DSTL
	BCS	FORCPY
REVCPY				; REVERSE DIRECTION COPY
;	CLC
	LDA 	ESTKL,X
	ADC	DSTL
	STA	DSTL
	LDA	ESTKH,X
	ADC	DSTH
	STA	DSTH
	CLC
	LDA 	ESTKL,X
	ADC	SRCL
	STA	SRCL
	LDA	ESTKH,X
	ADC	SRCH
	STA	SRCH
	INC 	ESTKH,X
REVCPYLP
	LDA	DSTL
	BNE	+
	DEC	DSTH
+	DEC	DSTL
	LDA	SRCL
	BNE	+
	DEC	SRCH
+	DEC	SRCL
	LDA	(SRC),Y
	STA	(DST),Y
	DEC 	ESTKL,X
	BNE	REVCPYLP
	DEC	ESTKH,X
	BNE	REVCPYLP
	BEQ	CPYMEX
FORCPY	INC 	ESTKH,X
FORCPYLP
	LDA	(SRC),Y
	STA	(DST),Y
	INC	DSTL
	BNE	+
	INC	DSTH
+	INC	SRCL
	BNE	+
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	FORCPYLP
	DEC	ESTKH,X
	BNE	FORCPYLP
CPYMEX	INX
	INX
	RTS
end
;
; HOME
;
asm home
	DEX
	RTS
end
;
; SET CURSOR POSITION
; GOTOXY(X,Y)
;
asm gotoxy
	INX
	RTS
end
;
; SET VIEWPORT
; VIEWPORT(LEFT, TOP, RIGHT, BOTTOM)
;
asm viewport
	INX
	INX
	INX
	RTS
end
;
; CHAR OUT
; COUT(CHAR)
;
asm cout
	LDA	ESTKL,X
	ORA 	#$80
	BIT	ROMEN
	JSR	$FDED
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; CHAR IN
; RDKEY()
;
asm cin
	BIT	ROMEN
	STX	ESP
	JSR     $FD0C
	LDX	ESP
	DEX
	STA     ESTKL,X
	LDY	#$00
	STY     ESTKH,X
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; PRINT STRING
; PRSTR(STR)
;
asm prstr
	LDY	#$00
	LDA     ESTKL,X
	STA     SRCL
	LDA     ESTKH,X
	STA     SRCH
        STY	ESTKH,X
	LDA     (SRC),Y
	STA     ESTKL,X
	BEQ     +
	BIT	ROMEN
-	INY
	LDA	(SRC),Y
	ORA	#$80
	JSR	$FDED
	TYA
	CMP	ESTKL,X
	BNE	-
	BIT	LCRDEN+LCBNK2
+	RTS
end
;
; PRINT BYTE
;
asm prbyte
	LDA	ESTKL,X
	STX     ESP
	BIT	ROMEN
	JSR	$FDDA
	LDX     ESP
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; PRINT WORD
;
asm prword
	LDA	ESTKH,X
	TAY
	LDA	ESTKL,X
	STX     ESP
	TAX
	TYA
	BIT	ROMEN
	JSR	$F941
	LDX     ESP
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; READ STRING
; STR = RDSTR(PROMPTCHAR)
;
asm rdstr
	LDA     ESTKL,X
	STA     $33
	STX     ESP
	BIT	ROMEN
	JSR     $FD6A
	STX     $01FF
-	LDA	$01FF,X
	AND	#$7F
	STA	$01FF,X
	DEX
	BPL	-
	LDX     ESP
	LDA     #$FF
	STA     ESTKL,X
	LDA     #$01
	STA     ESTKH,X
	BIT	LCRDEN+LCBNK2
	RTS
end
asm toupper
	LDA     ESTKL,X
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SEC
	SBC     #$20
	STA     ESTKL,X
+	RTS
end
asm uword_isge
	STY	IPY
	LDY	#$00
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
asm uword_isle
	STY	IPY
	LDY	#$00
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
asm uword_isgt
	STY	IPY
	LDY	#$FF
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
asm uword_islt
	STY	IPY
	LDY	#$FF
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
def crout
    cout($0D)
end
;
; ProDOS routines
;
def getpfx(path)
    byte params[3]

    ^path    = 0
    params.0 = 1
    params:1 = path
    perr     = syscall($C7, @params)
    return path
end
def setpfx(path)
    byte params[3]

    params.0 = 1
    params:1 = path
    perr     = syscall($C6, @params)
    return path
end
def online
    byte params[4]

    params.0 = 2
    params.1 = 0
    params:2 = databuff
    perr     = syscall($C5, @params)
    return databuff
end
def open(path, buff)
    byte params[6]

    params.0 = 3
    params:1 = path
    params:3 = buff
    params.5 = 0
    perr     = syscall($C8, @params)
    return params.5
end
def close(refnum)
    byte params[2]

    params.0 = 1
    params.1 = refnum
    perr     = syscall($CC, @params)
    return perr
end
def read(refnum, buff, len)
    byte params[8]

    params.0 = 4
    params.1 = refnum
    params:2 = buff
    params:4 = len
    params:6 = 0
    perr     = syscall($CA, @params)
    return params:6
end
def write(refnum, buff, len)
    byte params[8]

    params.0 = 4
    params.1 = refnum
    params:2 = buff
    params:4 = len
    params:6 = 0
    perr     = syscall($CB, @params)
    return params:6
end
def create(path, access, type, aux)
    byte params[12]

    params.0  = 7
    params:1  = path
    params.3  = access
    params.4  = type
    params:5  = aux
    params.7  = $1
    params:8  = 0
    params:10 = 0
    perr      = syscall($C0, @params)
    return perr
end
def destroy(path)
    byte params[12]

    params.0 = 1
    params:1 = path
    perr     = syscall($C1, @params)
    return perr
end
def newline(refnum, emask, nlchar)
    byte params[4]

    params.0 = 3
    params.1 = refnum
    params.2 = emask
    params.3 = nlchar
    perr     = syscall($C9, @params)
    return perr
end

;
; Utility routines.
; 
; A DCI string is one that has the high bit set for every character except the last.
; More efficient than C or Pascal strings.
;
def dcitos(dci, str)
    byte len, c
    len = 0
    repeat
        c = (dci).[len]
        len = len + 1
        (str).[len] = c & $7F
    until !(c & $80)
    ^str = len
    return len
end
def stodci(str, dci)
    byte len, c
    len = ^str
    if len == 0
        return
    fin
    c = toupper((str).[len]) & $7F
    len = len - 1
    (dci).[len] = c
    while len
    	c = toupper((str).[len]) | $80
    	len = len - 1
    	(dci).[len] = c
    loop
    return ^str
end
;
; Heap routines.
;
def availheap
    byte fp
    return @fp - heap
end
def allocheap(size)
    word addr
    addr = heap
    heap = heap + size
;    if heap >= @addr
;        puts(@heaperr)
;        exit(1)
;    fin
    return addr
end
def freeheap(size)
    heap = heap - size;
    return @size - heap;
end
def markheap
    return heap;
end
def releaseheap(newheap)
    heap = newheap;
    return @newheap - heap;
end
;def availxheap(void)
;    return 0xC000 - xheap;
;end
;def allocxheap(int size)
;    uword addr = xheap;
;    xheap += size;
;    if (xheap >= 0xC000)
;    {
;        printf("Error: xheap extinguished.\n");
;        exit (1);
;    }
;    return addr;
;end
;def freexheap(int size)
;    xheap -= size;
;    return 0xC000 - heap;
;end
;def markxheap(void)
;    return xheap;
;end
;def releasexheap(uword newxheap)
;    xheap = newxheap;
;    return 0xC000 - xheap;
;end
;
; Copy from data mem to code mem.
;
;def xmemcpy(uword src, uword dst, uword size)
;    while (size--)
;        mem_code[dst + size] = mem_data[src + size]; 
;end
;
; Copy from code mem to data mem.
;
;def memxcpy(uword src, uword dst, uword size)
;    while (size--)
;        mem_data[dst + size] = mem_code[src + size]; 
;end
;
; DCI table routines,
;
def dumptbl(tbl)
    byte len

    while ^tbl
        len = 0
        while ^tbl & $80
            cout(^tbl)
            tbl = tbl + 1
            len = len + 1
        loop
        cout(^tbl)
        tbl = tbl + 1
        cout(':')
        while len < 15
            cout(' ')
            len = len + 1
        loop
        cout('$')
        prword(*tbl)
        crout
        tbl = tbl + 2
    loop
end
def lookuptbl(dci, tbl)
    byte str[20]
    word match

    while ^tbl
        dcitos(tbl, @str)
        prstr(@str)
        crout
        match = dci
        while ^tbl == ^match
            if !(^tbl & $80)
                return (tbl):1
            fin
            tbl   = tbl   + 1
            match = match + 1
        loop
        while ^tbl & $80
            tbl = tbl + 1
        loop
        tbl = tbl + 3
    loop
    prstr(@luerrstr)
    dcitos(dci, @str)
    prstr(@str)
    crout
    return 0
end
def addtbl(dci, val, last)
    while ^dci & $80
        ^*last = ^dci
        *last  = *last + 1
        dci    = dci   + 1
    loop
    ^*last = ^dci
    *last  = *last + 1
    **last = val
    *last  = *last + 2
end
;
; Symbol table routines.
;
def dumpsym
    ;printf("\nSystem Symbol Table:\n");
    dumptbl(@symtbl)
end
def lookupsym(sym)
    return lookuptbl(sym, @symtbl)
end
def addsym(sym, addr)
    return addtbl(sym, addr, @lastsym);
end
;
; Module routines.
;
def dumpmod
    ;printf("\nSystem Module Table:\n");
    dumptbl(@modtbl)
end
def lookupmod(mod)
    return lookuptbl(mod, @modtbl)
end
def addmod(mod)
    return addtbl(mod, @lastmod)
end
def adddef(bank, addr)
    (lastdef).0 = $20 ; JSR $03D6
    (lastdef):1 = $03D6
    (lastdef).3 = bank
    (lastdef):4 = addr
    prstr(@adddefstr)
    prword(lastdef)
    crout
    lastdef = lastdef + 6
    return lastdef - 6
end
def lookupdef(bank, addr)
    word entry

    entry = @deftbl
    while ^entry == $20
        if (entry):4 == addr
            if (entry).3 == bank
                return entry
            fin
        fin
        entry = entry + 6
    loop
    return 0
end
def lookupextern(esd, index)
    word sym
    byte str[16]
    while ^esd
        sym = esd
        esd = esd + dcitos(esd, @str)
        if (esd).0 & $10 and (esd).1 == index
            return lookupsym(sym)
        fin
        esd = esd + 3
    loop
    return 0
end
def loadmod(mod)
    word refnum, len, size,modend, bytecode, fixup, addr, init, modaddr, modfix
    word moddep, rld, esd, cdd, sym;
    byte str[16]
    byte filename[64]
    byte header[128]

    dcitos(mod, @filename)
    prbyte(filename)
    cout(' ')
    prstr(@filename)
    crout
    refnum = open(@filename, iobuffer)
    if refnum > 0
    	modaddr = markheap
        init = 0
        len = read(refnum, @header, 128)
        prstr(@modlenstr)
        prword(len)
        crout
        if len > 4 and header:2 == $DA7E ; DAVE
            ;
            ; This is a relocatable bytecode module.
            ;
            prstr(@davestr)
            crout
            bytecode = header:4
            init     = header:6
            moddep   = @header + 8
            if ^moddep
                ;
                ; Load module dependencies.
                ;
                close(refnum)
                while ^moddep
                    if lookupmod(moddep) == 0
                    	dumpmod
                        if loadmod(moddep) <> 0
                    	    dumpmod                            
			    return perr
			fin
                    fin
                    moddep = moddep + dcitos(moddep, @str)
                    prstr(@str)
                    crout
                loop
                modaddr = markheap
                refnum  = open(@filename, iobuffer)
                len     = read(refnum, modaddr, 128)
            fin
        else
            memcpy(modaddr, @header, len)
        fin
        addr = modaddr + len;
        repeat
            len  = read(refnum, addr, 4096)
            addr = addr + len
        until len <= 0
        close(refnum)
        size = addr - modaddr
        len      = *modaddr
        modend   = modaddr  + len
        modfix   = modaddr  - MODADDR
        bytecode = bytecode + modfix
        rld      = modaddr  + len ; Re-Locatable Directory
        cdd      = rld            ; Code Definition Directory
        esd      = rld            ; Extern+Entry Symbol Directory
        while ^esd <> $00 ; Scan to end of RLD
            esd = esd + 4
	loop
        esd = esd + 1
        ;if showstate
            ;
            ; Dump different parts of module.
            ;
            prstr(@modsizestr)
            prword(size)
            crout
            ;printf("Module code+data size: %d\n", len);
            prstr(@modlenstr)
            prword(len)
            crout
            ;printf("Module bytecode: $%04X\n", bytecode);
            prstr(@modcodestr)
            prword(bytecode)
            crout
            ;printf("Module init: $%04X\n", init);
            prstr(@modinitstr)
            prword(init)
            crout
        ;fin
        ;
        ; Print out the Re-Location Dictionary.
        ;
        ;if showstate
            ;printf("\nRe-Location Dictionary:\n")
        ;fin
        while ^rld
            if ^rld == $02
                addr    = (rld):1 + modfix
                (rld):1 = addr
                adddef(0, addr)
                prstr(@defstr)
            else
                addr = (rld):1 + modfix
                if ^rld & $80
                    fixup = *addr
                else
                    fixup = ^addr
                fin
                if ^rld & $10
                    prstr(@externstr)
                    prbyte((rld).3);"\tEXTERN[$%02X] ", rld[3]);
                    cout(']')
                    fixup = fixup + lookupextern(esd, (rld).3);
                else
                    prstr(@internstr);printf("\tINTERN      ")
                    fixup = fixup + modfix
                    if uword_isge(fixup, bytecode)
                        ;
                        ; Replace with call def dictionary.
                        ;
                        fixup = lookupdef(0, fixup)
                    fin
                fin
                if ^rld & $80
                    prstr(@wordstr);printf("WORD")
                    *addr = fixup
                else
                    prstr(@bytestr);printf("BYTE")
                    ^addr = fixup
                fin
                
            fin
            prstr(@addrstr)
            prword(addr)
            crout;printf("@$%04X\n", addr)
            rld = rld + 4
        loop
        ;if showstate printf("\nExternal/Entry Symbol Directory:\n")
        while ^esd
            sym = esd
            esd = esd + dcitos(esd, @str)
            if ^esd & $10
                ;if showstate printf("\tIMPORT %s[$%02X]\n", string, esd[1])
            elsif ^esd & $08
                addr = (esd):1 + modfix
                ;if showstate printf("\tEXPORT %s@$%04X\n", string, addr)
                if uword_isge(addr, bytecode)
                    addr = lookupdef(0, addr)
                fin
                addsym(sym, addr)
            fin
            esd = esd + 3
        loop
    else
        prstr(@readerrstr)
        crout
        perr = 0x100
        return perr
    fin
    ;
    ; Reserve heap space for relocated module.
    ;
    allocheap(modend - modaddr)
    ;
    ; Call init routine.
    ;
    if init
        init = adddef(0, init + modfix)
        cin
    	return init()
    fin
    return 0
end
;
; Command mode
;
def volumes
    word strbuf
    byte i

    strbuf = online()
    for i = 0 to 15
        ^strbuf = ^strbuf & $0F
	if ^strbuf
	    cout('/')
	    prstr(strbuf)
	    crout()
	fin
	strbuf = strbuf + 16
    next
end
def catalog(optpath)
    byte path[64]
    byte refnum
    byte firstblk
    byte entrylen, entriesblk
    byte i, type, len
    word entry, filecnt

    if ^optpath
        memcpy(@path, optpath, ^optpath + 1)
    else
        getpfx(@path)
        prstr(@path)
        crout()
    fin
    refnum = open(@path, iobuffer)
    if perr
        return perr
    fin
    firstblk = 1
    repeat
        if read(refnum, databuff, 512) == 512
            entry = databuff + 4
            if firstblk
                entrylen   = databuff.$23
                entriesblk = databuff.$24
                filecnt    = databuff:$25
                entry      = entry + entrylen
            fin
            for i = firstblk to entriesblk
                type = ^entry
                if type <> 0
                    len = type & $0F
                    ^entry = len
                    prstr(entry)
                    if type & $F0 == $D0 ; Is it a directory?
                        cout('/')
                        len = len + 1
		    elsif (entry).$10 == $FF
		        cout('*')
			len = len + 1
                    fin
                    for len = 19 - len downto 0
                        cout(' ')
                    next
                    filecnt = filecnt - 1
                fin
                entry = entry + entrylen
            next
            firstblk = 0
        else
            filecnt = 0
        fin
    until filecnt == 0
    close(refnum)
    crout()
    return 0
end
def stripchars(strptr)
    while ^strptr and ^(strptr + 1) <> ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
	return ^strptr
end
def stripspaces(strptr)
	while ^strptr and ^(strptr + ^strptr) <= ' '
        ^strptr = ^strptr - 1
    loop
    while ^strptr and ^(strptr + 1) <= ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
end
def striptrail(strptr)
    byte i

    for i = 1 to ^strptr
        if (strptr)[i] == ' '
	    ^strptr = i - 1
	    return
	fin
    next
end
def parsecmd(strptr)
    byte cmd

    cmd = 0
    stripspaces(strptr)
    if ^strptr
        cmd = ^(strptr + 1)
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    fin
    stripspaces(strptr)
    return cmd
end
def resetmemfiles
    ;
    ; Close all files
    ;
    ^$BFD8 = 0
    close(0)
    ;
    ; Set memory bitmap
    ;
    memclr($BF58, 24)
    ^$BF58 = $CF
    ^$BF6F = $01
end
def execsys(sysfile)
    byte refnum
    word len

    if ^sysfile
        memcpy($280, sysfile, ^sysfile + 1)
	striptrail(sysfile)
	refnum = open(sysfile, iobuffer)
	if refnum
	    len = read(refnum, $2000, $FFFF)
	    resetmemfiles()
	    if len
	        memcpy(sysfile, $280, ^$280 + 1)
		if stripchars(sysfile) and ^$2000 == $4C and *$2003 == $EEEE
		    stripspaces(sysfile)
		    if ^$2006 <= ^sysfile
		        memcpy($2006, sysfile, ^sysfile + 1)
		    fin
		fin
	        striptrail($280)
		exec()
	    fin
	fin
    fin
end
def execmod(modfile)
    byte dci[17]
    word saveheap, savemod, savesym, savedef
  
    if stodci(modfile, @dci)
        saveheap = heap
        savemod  = lastmod
        savesym  = lastsym
	savedef  = lastdef
	loadmod(@dci)
        heap     = saveheap
        lastmod  = savemod
        lastsym  = savesym
	lastdef  = savedef
	^heap    = 0
	^lastmod = 0
	^lastsym = 0
	^lastdef = 0
  fin
end
def initsyms
    byte dci[17]
    word globals

    stodci(@stdlibstr, @dci)
    addmod(@dci, 1)
    globals = @exports
    while *globals
        stodci(*globals, @dci)
        globals = globals + 2
        addsym(@dci, *globals)
        globals = globals + 2
    loop
end

resetmemfiles()
prstr(@version)
crout()
initsyms
while 1
    prstr(getpfx(@prefix))
    cmdptr = rdstr($BA)
    when toupper(parsecmd(cmdptr))
        is 'Q'
	    reboot()
	is 'C'
	    catalog(cmdptr)
	is 'P'
	    setpfx(cmdptr)
	is 'V'
	    volumes();
	is '-'
	    execsys(cmdptr)
	    perr = $46
	is '+'
	    execmod(cmdptr)
    wend
    if perr
        prstr(@errorstr)
	prbyte(perr)
        perr = 0
    else
        prstr(@okstr)
    fin
    crout()
loop
done