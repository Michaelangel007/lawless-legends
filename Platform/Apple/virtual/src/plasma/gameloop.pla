///////////////////////////////////////////////////////////////////////////////////////////////////
// Handy constants.
const FALSE = 0
const TRUE  = !FALSE
const NULL  = 0

///////////////////////////////////////////////////////////////////////////////////////////////////
// Fixed memory locations
const displayEngine = $6000   // main mem (raycaster and tile engine at same location)
const expandVec     = $2000   // aux mem (only for raycaster)
const fontEngine    = $BA00   // main mem

///////////////////////////////////////////////////////////////////////////////////////////////////
// Resource numbers
const RES_NUM_RAYCASTER   = 1
const RES_NUM_EXPAND_VEC  = 2
const RES_NUM_FONT_ENGINE = 3
const RES_NUM_TILE_ENGINE = 4

///////////////////////////////////////////////////////////////////////////////////////////////////
// Hardware addresses.
const keyboard  = $C000
const keystrobe = $C010

///////////////////////////////////////////////////////////////////////////////////////////////////
// Memory manager definitions

// Resource types
const RES_TYPE_CODE     = 1
const RES_TYPE_2D_MAP   = 2
const RES_TYPE_3D_MAP   = 3
const RES_TYPE_TILE     = 4
const RES_TYPE_TEXTURE  = 5
const RES_TYPE_SCREEN   = 6
const RES_TYPE_FONT     = 7
const RES_TYPE_MODULE   = 8
const RES_TYPE_BYTECODE = 9
const RES_TYPE_FIXUP    = 10
const RES_TYPE_PORTRAIT = 11

// Memory banks
const MAIN_MEM = 0
const AUX_MEM  = 1

// Command codes
const RESET_MEMORY   = $10
const REQUEST_MEMORY = $11
const LOCK_MEMORY    = $12
const UNLOCK_MEMORY  = $13
const SET_MEM_TARGET = $14
const START_LOAD     = $15
const QUEUE_LOAD     = $16
const FINISH_LOAD    = $17
const FREE_MEMORY    = $18
const CALC_FREE      = $19
const DEBUG_MEM      = $1A
const CHAIN_LOADER   = $1E
const FATAL_ERROR    = $1F

///////////////////////////////////////////////////////////////////////////////////////////////////
// Other constants
const callbacks = $300

// 3D map start
//const OVERMAP_NUM = 11
//const OVERMAP_IS_3D = 1
// 2D map start
const OVERMAP_NUM = 1
const OVERMAP_IS_3D = 0

///////////////////////////////////////////////////////////////////////////////////////////////////
// Predefined functions, for circular calls or out-of-order calls
predef setWindow2, initCmds

///////////////////////////////////////////////////////////////////////////////////////////////////
// Font engine variables
const wndleft   = $70  // left edge of the window
const wndwdth   = $71  // right edge (NOT width) of text window
const wndtop    = $72  // top of text window
const wndbtm    = $73  // bottom+1 of text window
const cursh     = $74  // Cursor H-pos 0-39
const cursv     = $75  // Cursor V-pos 0-23

///////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
byte mapNum
byte mapIs3D
word pFont
word pMap
word cmdTbl[64]
word triggerOriginX, triggerOriginY
word triggerTbl
byte redraw
byte frameLoaded = 0
byte textDrawn = FALSE
byte needRender = FALSE

word skyNum = 9
word groundNum = 10
byte portraitNum = 1

// Queue setMap / teleport, since otherwise script might be replaced while executing
byte q_mapIs3D
byte q_mapNum = 0
word q_x
word q_y
byte q_dir

///////////////////////////////////////////////////////////////////////////////////////////////////
// Definitions used by assembly code
asm __defs

; Use hi-bit ASCII for Apple II
!convtab "../../include/hiBitAscii.ct"

; Headers
!source "../../include/global.i"
!source "../../include/plasma.i"
!source "../../include/mem.i"
!source "../../include/fontEngine.i"

; Optional debug printing support
DEBUG   = 1
!if DEBUG { !source "../../include/debug.i" }

; General use
tmp         = $2
pTmp        = $4

; NOTE ABOUT ABSOLUTE ADDRESSES
; You cannot use them: this code, including variable space, can be loaded *anywhere*.
; So don't declare any variables as !byte or !word here.

end

///////////////////////////////////////////////////////////////////////////////////////////////////
// API to call rendering engine (same API for raycaster and tile engine)
asm initDisplay   // params: mapNum, pMapData, x, y, dir
        +asmPlasm 5
        jmp $6000
end
asm flipToPage1  // no params
        +asmPlasm 0
        jmp $6003
end
asm getPos       // params: @x, @y
        +asmPlasm 2
        jmp $6006
end
asm setPos       // params: x, y
        +asmPlasm 2
        jmp $6009
end
asm getDir       // no params; returns: dir (0-15)
        +asmPlasm 0
        jmp $600C
end
asm setDir       // params: dir (0-15)
        +asmPlasm 1
        jmp $600F
end
asm advance      // no params; return: 0 if same pos, 1 if new pos, 2 if new pos and scripted
        +asmPlasm 0
        jmp $6012
end
asm setColor     // params: slot (0=sky/1=ground), color (0-17)
        +asmPlasm 2
        jmp $6015
end
asm render      // no params
        +asmPlasm 0
        jmp $6018
end
///////////////////////////////////////////////////////////////////////////////////////////////////
asm pushAuxStr     // params: none; ret: $200 (inbuf)
        stx tmp     ; save PLASMA's X reg eval stack index
        tsx
        lda $103,x  ; get PLASMA's Y-reg value from its place in the stack
        tay

        ; Create the following subroutine, used to copy chars from aux to main:
        ;0010-   8D 03 C0    STA   $C003
        ;0013-   B1 F4       LDA   ($F4),Y
        ;0015-   8D 02 C0    STA   $C002
        ;0018-   60          RTS
        lda #$8D
        sta $10
        sta $15
        ldx #2
        stx $16
        inx
        stx $11
        lda #$C0
        sta $12
        sta $17
        lda #$B1
        sta $13
        lda #$F4
        sta $14
        lda #$60
        sta $18

        ; Get string length and save it
        iny             ; advance to next code byte
        bne +
        inc $F4         ; next pg if necessary
+       jsr $10
        sta $200
        ldx #0
        ; Copy entire string
.lup    cpx $200
        beq ++
        iny             ; advance to next code byte
        bne +
        inc $F4         ; next pg if necessary
+       jsr $10         ; now fetch the byte from aux mem
        inx
        sta $200,x      ; and stuff it in the string / input buffer
        bne .lup        ; always taken
++      tsx
        tya
        sta $103,x      ; modify PLASMA's Y reg so it picks up code execution just after the string
        ldx tmp         ; retrieve PLASMA's eval stack ptr
        dex             ; make room for ret value
        lda #0
        sta evalStkL,x  ; return value lo (<$200)
        lda #2
        sta evalStkH,x  ; and hi (>$200)
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
asm blitPortrait      // params: srcData, dstScreenPtr
        +asmPlasm 2

        ; Save the dest pointer
        sta pTmp
        sty pTmp+1

        ; Save the source pointer
        lda evalStkL+1,x
        sta tmp
        lda evalStkH+1,x
        sta tmp+1

        ; Create the following subroutine, used to copy pixels from aux to main:
        ; 0010-   8D 03 C0    STA   $C003
        ; 0013-   B1 02       LDA   ($02),Y
        ; 0015-   91 04       STA   ($04),Y
        ; 0017-   88          DEY
        ; 0018-   10 F9       BPL   $0013
        ; 001A-   8D 02 C0    STA   $C002
        ; 001D-   60          RTS
        lda #$8D
        sta $10
        sta $1A
        ldx #2
        stx $14
        stx $1B
        inx
        stx $11
        lda #$C0
        sta $12
        sta $1C
        lda #$B1
        sta $13
        lda #$91
        sta $15
        inx
        stx $16
        lda #$88
        sta $17
        lda #$10
        sta $18
        lda #$F9
        sta $19
        lda #$60
        sta $1D

        ; Outer copy loop
        ldx #128  ; line count
.loop   ldy #17   ; byte count minus 1
        jsr $10   ; copy pixel bytes

        ; Advance to next row of data
        lda tmp
        clc
        adc #18
        sta tmp
        bcc +
        inc tmp+1
+
        ; Fun code to advance to the next hi-res line
        ldy pTmp+1
        iny
        iny
        iny
        iny
        cpy #$40
        bcc .ok2
        tya
        sbc #$20  ; carry already set
        tay
        lda pTmp
        eor #$80
        bmi .ok
        iny
        cpy #$24
        bcc .ok
        ldy #$20
        adc #$27  ; carry was set, so actually adding $28
.ok     sta pTmp
.ok2    sty pTmp+1

        ; Loop until we've done all rows.
        dex
        bne .loop

        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Simply retrieve the X register. Used to double-check that we're not leaking PLASMA eval
// stack entries.
asm getXReg
        +asmPlasm 0
        txa
        ldy #0
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a string
asm puts
        +asmPlasm 1
        sta pTmp
        sty pTmp+1
        ldy #0
        lda (pTmp),y
        tax
        iny
-       lda (pTmp),y
        ora #$80
        jsr cout
        iny
        dex
        bne -
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print part of a string, until we hit the end or a '%' code. Return how far we got, or -1 for end.
asm partialPrintf
!zone {
        +asmPlasm 2
        lda evalStkL+1,x    ; get string pointer
        sta pTmp
        lda evalStkH+1,x
        sta pTmp+1
        ldy #0
        lda (pTmp),y        ; get length byte
        sec
        sbc evalStkL,x      ; minus offset
        sta tmp             ; to count of characters left to print
        bcc .eos            ; avoid overrunning
        beq .eos
        lda evalStkL,x      ; get desired offset into string
        tay
        iny                 ; increment past length byte
-       lda (pTmp),y
        ora #$80
        cmp #'%'            ; stop if we hit % code
        beq +
        jsr cout
        iny
        dec tmp             ; otherwise go until end of string
        bne -
.eos    ldy #$FF            ; if we hit end of string, return -1
        tya
        rts
+       dey                 ; adjust back for length byte
        tya                 ; that's the lo byte of return
        ldy #0              ; hi byte of return is zero
        rts
}
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a 16-bit hex value
asm printHex
        +asmPlasm 1
        tax
        tya
        jmp prntax
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a single character
asm printChar
        +asmPlasm 1
        ora #$80
        jmp cout
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a carriage return
asm crout
        +asmPlasm 0
        jmp crout
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Ring the bell
asm beep
        +asmPlasm 0
        jmp bell
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Read a string from the keyboard, turn it into a PLASMA string and return a pointer to the string.
asm readStr
        +asmPlasm 0
        jsr getln1
        txa
        pha
        beq +
-       lda inbuf-1,x
        and #$7F
        sta inbuf,x
        dex
        bne -
+       pla
        sta inbuf,x
        lda #<inbuf
        ldy #>inbuf
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Send a command to the memory manager
// Params: cmd, mainOrAux, amount
asm loader
        +asmPlasm 3
        lda evalStkL+2,x        ; command code
        pha
        lda evalStkL+1,x        ; main or aux
        lsr
        ldy evalStkH,x          ; address (or other param)
        lda evalStkL,x
        tax
        pla
        bcs +
        jsr mainLoader          ; ret value in X=lo/Y=hi
        txa
        rts
+       jsr auxLoader           ; ditto
        txa
        rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set up the font engine
// Params: pFont
asm initFontEngine
        +asmPlasm 1
        ldy evalStkL,x   ; font engine likes *lo* byte in Y
        lda evalStkH,x   ; hi byte in X
        tax
        jsr setFONT
        ; Set to write text on both hi-res pages at the same time
        lda #pHGR3
        jsr displayMODE
        ; Set to normal (non-inverse) text
        lda #pNORMAL
        jmp drawMODE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Jump straight to the system monitor
// Params: None
asm goMon
        bit setROM
        jmp $FF69
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Execute a monitor breakpoint
// Params: None
asm brk
        bit setROM
        bit setText
        bit page1
        brk
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Use the font engine to clear the current text window
// Params: None
asm clearWindow
        +asmPlasm 0
        jmp clearWINDOW
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display a string using the font engine, but without any break checking.
// Params: pStr
asm rawDisplayStr
  +asmPlasm 1
  pha
  tya
  tax           ; hi byte of addr to X
  pla
  tay           ; lo byte of addr to Y
  jmp printSTR
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display a string using the font engine. Automatically splits lines to keep words from breaking.
// Params: pStr
asm displayStr
    +asmPlasm 1
    sta pTmp
    sty pTmp+1
    ldy #0
    lda (pTmp),y  ; get string length
    beq .done     ; if zero, get out.
    inc pTmp      ; advance past string len
    bne +
    inc pTmp+1
+
--  tax           ; length will be tracked in X reg
    ldy #0
-   lda (pTmp),y  ; next character
    cmp #$20      ; check for invalid control chars
    bcc +
    cmp #$80      ; check for invalid hi-bit chars
    bcc ++
+   lda #$C4      ; failure path
    jsr $fded
    brk
++  dex           ; used a char
    cmp #$20      ; is the char a space?
    beq +
    sta $281,y    ; no, save to word buffer
    iny
    cpx #0        ; last char?
    bne -
+   sty $280      ; found a word break; save word length.
    tya
    sec
    adc pTmp      ; advance main pointer over word
    sta pTmp
    bcc +
    inc pTmp+1
+   txa           ; save X reg
    pha
    tya           ; string length
    clc
    adc cursh     ; ...plus cursor pos
    sec
    sbc #2
    cmp wndwdth   ; ...vs. window width
    bcc +
    lda #$D       ; force a line break
    jsr printCHAR
+   tya           ; if zero length (e.g. string starts with space), just print the space
    beq +
    ldy #$80      ; now display string at $280 (word buf)
    ldx #2
    jsr printSTR
    lda cursh
    cmp wndleft
    beq ++
+   lda #$20
    jsr printCHAR
++  pla           ; restore string length
    bne --
.done:
    lda #$d
    jmp printCHAR
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Convert a PLASMA string (starts with length, lo-bit ascii) to an assembly string
// (zero-terminated, hi-bit ascii).
asm toAsmStr
  lda evalStkL,x
  sta pTmp
  lda evalStkH,x
  sta pTmp+1
  ldy #0
  lda (pTmp),y
  beq +
  sta tmp
- iny
  lda (pTmp),y
  ora #$80
  dey
  sta (pTmp),y
  iny
  dec tmp
  bne -
  lda #0
  sta (pTmp),y
+ rts
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// General methods

///////////////////////////////////////////////////////////////////////////////////////////////////
// Fatal error: print message and stop the system.
def fatal(msg)
  toAsmStr(msg)
  loader(FATAL_ERROR, MAIN_MEM, msg)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a signed decimal word
def printDec(n)
  word n0
  if n < 0;     printChar('-');           n = -n;      fin
  n0 = n
  if n0 > 9999; printChar('0' + n/10000); n = n%10000; fin
  if n0 > 999;  printChar('0' + n/1000);  n = n%1000;  fin
  if n0 > 99;   printChar('0' + n/100);   n = n%100;   fin
  if n0 > 9;    printChar('0' + n/10);    n = n%10;    fin
  printChar('0' + n)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Print a formatted string a'la C printf, with up to four parameters.
def printf4(str, arg1, arg2, arg3, arg4)
  word pos
  word curArg
  word p
  pos = 0
  curArg = @arg1
  while TRUE
    pos = partialPrintf(str, pos)
    if pos < 0
      break
    fin
    p = str + pos + 2
    when ^p
      is 'x'
        printHex(*curArg); break
      is 'd'
        printDec(*curArg); break
      is 's'
        puts(*curArg); break
      is '%'
        printChar('%'); break
      otherwise
        printHex(^p); fatal("Unknown % code")
    wend
    curArg = curArg + 2
    pos = pos + 2
  loop
end

def printf1(str, arg1); printf4(str, arg1, 0, 0, 0); end
def printf2(str, arg1, arg2); printf4(str, arg1, arg2, 0, 0); end
def printf3(str, arg1, arg2, arg3); printf4(str, arg1, arg2, arg3, 0); end

///////////////////////////////////////////////////////////////////////////////////////////////////
def parseDec(str)
  word n
  word pend
  word p
  byte neg
  neg = FALSE
  n = 0
  p = str + 1
  pend = p + ^str
  while p < pend
    if p == (str+1) and ^p == '-'
      neg = TRUE
    elsif ^p >= '0' and ^p <= '9'
      n = (n*10) + (^p - '0')
    else
      break
    fin
    p = p+1
  loop

  if neg; return -n; fin
  return n
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Get a keystroke and convert it to upper case
def getUpperKey()
  byte key
  while ^keyboard < 128
  loop
  key = ^keyboard & $7F
  ^keystrobe
  if key >= $60
    key = key - $20
  fin
  return key
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set the sky color (relevant to 3D display only)
def setSky(num)
  skyNum = num
  setColor(0, skyNum)
  needRender = TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to the next sky color (3D only)
def nextSky()
  setSky((skyNum + 1) % 18)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set the ground color (relevant to 3D display only)
def setGround(num)
  groundNum = num
  setColor(1, groundNum)
  needRender = TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to the next ground color (3D only)
def nextGround()
  setGround((groundNum + 1) % 18)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to text mode and display mem manager debug printout, get a key, switch back to graphics.
def debugMem(bank)
  ^$c051
  ^$c054
  loader(DEBUG_MEM, bank, 0)
  getUpperKey()
  ^$c050
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Establish a keystroke -> command association in the command table
def initCmd(key, func)
  if key >= $60
    key = key - $20
  fin
  cmdTbl[key-$20] = func
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load the Frame Image, and lock it.
def loadFrameImg()
  byte img
  img = mapIs3D+2
  if frameLoaded <> img
    if frameLoaded
      loader(UNLOCK_MEMORY,MAIN_MEM, $2000)
      loader(FREE_MEMORY,  MAIN_MEM, $2000)
    fin
    loader(SET_MEM_TARGET, MAIN_MEM, $2000)
    loader(QUEUE_LOAD,     MAIN_MEM, img<<8 | RES_TYPE_SCREEN)
    loader(LOCK_MEMORY,    MAIN_MEM, $2000)
    frameLoaded = img
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load code and data, set up everything to display a 3D map
def initMap(x, y, dir)
  // Set up the command table
  initCmds()

  // Reset memory (our module will stay since memory manager locked it upon load)
  loader(RESET_MEMORY, MAIN_MEM, 0)

  // Load the font engine and its font
  loader(SET_MEM_TARGET, MAIN_MEM, fontEngine)
  loader(QUEUE_LOAD,     MAIN_MEM, RES_NUM_FONT_ENGINE<<8 | RES_TYPE_CODE)

  loader(SET_MEM_TARGET, MAIN_MEM, $9000)
  pFont = loader(QUEUE_LOAD, MAIN_MEM, 1<<8 | RES_TYPE_FONT)

  // Queue loading of the raycaster or tile engine and the map data
  loader(SET_MEM_TARGET, MAIN_MEM, displayEngine)
  if mapIs3D
    loader(QUEUE_LOAD, MAIN_MEM, RES_NUM_RAYCASTER<<8 | RES_TYPE_CODE)
    pMap = loader(QUEUE_LOAD, MAIN_MEM, mapNum<<8 | RES_TYPE_3D_MAP)
    loader(SET_MEM_TARGET, AUX_MEM, expandVec)
    loader(QUEUE_LOAD, AUX_MEM, RES_NUM_EXPAND_VEC<<8 | RES_TYPE_CODE)
  else
    loader(QUEUE_LOAD, MAIN_MEM, RES_NUM_TILE_ENGINE<<8 | RES_TYPE_CODE)
    pMap = loader(QUEUE_LOAD, MAIN_MEM, mapNum<<8 | RES_TYPE_2D_MAP)
  fin

  // Load everything that we just queued
  loader(FINISH_LOAD, MAIN_MEM, 1) // 1 = keep open

  // Load the frame image (and lock it there)
  loadFrameImg()
  loader(FINISH_LOAD, MAIN_MEM, 1) // 1 = keep open

  // Start up the font engine
  initFontEngine(pFont)

  // Start up the display engine with map data and starting position. This will also load and
  // init the script module, if any, which will end up calling us back at the setScriptInfo
  triggerTbl = NULL
  setWindow2()
  initDisplay(mapNum, pMap, x, y, dir)
  needRender = FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def setWindow(top, btm, lft, rt)
  ^wndtop = top
  ^wndbtm = btm
  ^wndleft = lft
  ^wndwdth = rt
  ^cursv = ^wndtop
  ^cursh = ^wndleft
end

// Window for the map name bar
def setWindow1()
  setWindow(1, 2, 5, 17)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Window for the large upper right bar
def setWindow2()
  setWindow(3, 17, 22, 37)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Window for the mid-size lower right bar
def setWindow3()
  setWindow(18, 23, 23, 37)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Window for the map area (used for clearing it)
def setMapWindow()
  if mapIs3D
    setWindow(3, 19, 2, 19)
  else
    setWindow(3, 21, 2, 19)
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Check for script(s) attached to the current location, and call them if there are any.
def checkScripts()
  word x
  word y
  word p
  word pNext
  word script

  if !triggerTbl; return; fin
  setWindow2()
  getPos(@x, @y)
  x = x - triggerOriginX
  y = y - triggerOriginY
  p = triggerTbl
  while TRUE
    if ^p == $FF
      return
    fin
    pNext = p + p->1
    if ^p == y
      p = p + 2
      while p < pNext
        if x == ^p
          script = p=>1
          script()
        fin
        p = p + 3
      loop
    fin
    p = pNext
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Advance one step forward (3D maps only)
def moveForward()
  byte val
  val = advance()

  // If not blocked, render at the new position.
  if val > 0
    if !mapIs3D
      render()
      needRender = FALSE
    else
      needRender = TRUE
    fin
  fin

  // If we're on a new map tile, clear text from script(s) on the old tile.
  if val >= 2 and textDrawn
    clearWindow()
    textDrawn = FALSE
  fin

  // If there are script(s) on the new tile, run them.
  if val == 3
    checkScripts()
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Adjust player's direction plus or minus n increments
def adjustDir(n)
  setDir((getDir() + n) & 15)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Move backward one step (3D mode)
def moveBackward()
  adjustDir(8)
  moveForward()
  adjustDir(8)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Turn left (3D mode)
def rotateLeft()
  adjustDir(-1)
  needRender = TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Rotate to the right (3D mode)
def rotateRight()
  adjustDir(1)
  needRender = TRUE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Sidestep to the right (3D mode)
def strafeRight()
  adjustDir(4)
  moveForward()
  adjustDir(-4)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Sidestep to the left (3D mode)
def strafeLeft()
  adjustDir(-4)
  moveForward()
  adjustDir(4)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def moveNorth()
  setDir(0)
  moveForward()
end

def moveEast()
  setDir(4)
  moveForward()
end

def moveSouth()
  setDir(8)
  moveForward()
end

def moveWest()
  setDir(12)
  moveForward()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Switch to a new map (2D or 3D) and establish position on it
def setMap(is3D, num, x, y, dir)
  if is3D == mapIs3D and num == mapNum
    setPos(x, y)
    setDir(dir)
    needRender = TRUE
  else
    flipToPage1()
    setWindow1();   clearWindow()
    rawDisplayStr("Traveling...")
    setMapWindow(); clearWindow()    
    setWindow2();   clearWindow()
    mapIs3D = is3D
    mapNum = num
    initMap(x, y, dir)
  fin
  // Don't check scripts, because we often land on an "Exit to wilderness?" script
  //NO:checkScripts()  
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def kbdTeleport()
  word x, y
  byte dir
  
  flipToPage1()
  ^$c053
  if ^$25 < 23; ^$25 = 23; fin
  getPos(@x, @y)
  printf3("\nCurrent: X=%d Y=%d Facing=%d\n", x, y, getDir())

  puts("3D : ")
  mapIs3D = parseDec(readStr())
  puts("Map: ")
  mapNum = parseDec(readStr())
  puts("X  : ")
  x = parseDec(readStr())
  puts("Y  : ")
  y = parseDec(readStr())
  puts("Facing: ")
  dir = parseDec(readStr())

  ^$c052

  setMap(mapIs3D, mapNum, x, y, dir)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def showPos()
  word x, y
  byte dir
  
  flipToPage1()
  ^$c053
  if ^$25 < 23; ^$25 = 23; fin
  getPos(@x, @y)
  printf2("\nX=%d Y=%d ", x, y)
  if mapIs3D
    printf3("Facing=%d Sky=%d Ground=%d", getDir(), skyNum, groundNum)
  fin
  puts("\nHit any key.\n")
  getUpperKey()
  ^$c052
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def queue_setMap(is3D, num, x, y, dir)
  q_mapIs3D = is3D
  q_mapNum = num
  q_x = x
  q_y = y
  q_dir = dir
end

///////////////////////////////////////////////////////////////////////////////////////////////////
def queue_teleport(x, y, dir)
  queue_setMap(mapIs3D, mapNum, x, y, dir)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Get a key and dispatch it to a command. Then do it again, forever.
def kbdLoop()
  word key, func
  byte xreg, tmp
  xreg = getXReg()
  while TRUE
    tmp = getXReg()
    if tmp <> xreg
      printf2("Error: x reg changed from %x to %x\n", xreg, tmp)
      brk()
    fin
    key = getUpperKey()
    key = key - $20
    if key >= 0 and key < $40
      func = cmdTbl[key]
      if func; func(); fin
    fin
    if q_mapNum
      setMap(q_mapIs3D, q_mapNum, q_x, q_y, q_dir)
      q_mapNum = 0
    fin
    if needRender
      render()
      needRender = FALSE
    fin
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set initial info for the scripts on this map: the trigger table and the name of the map. This
// is called by the init function for the scripts.
def setScriptInfo(mapName, trigTbl)

  // Grab the trigger table origins (used so the table can be more compact)
  triggerOriginX = trigTbl=>0
  triggerOriginY = trigTbl=>2

  // Record the trigger table pointer
  triggerTbl = trigTbl + 4

  // Display map name
  setWindow1()
  clearWindow()
  rawDisplayStr(mapName)

  // Back to the main text window.
  setWindow2()
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Called by scripts to display a string. We set the flag noting that something has been
// displayed, then use an assembly routine to do the work.
def scriptDisplayStr(str)
  textDrawn = TRUE
  displayStr(str)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Get a key, and don't return until it's Y or N (or lower-case of those). Returns 1 for Y.
def getYN()
  byte key
  while TRUE
    key = getUpperKey()
    if key == 'Y'
      return 1
    elsif key == 'N'
      clearWindow()
      textDrawn = FALSE
      return 0
    fin
    beep()
  loop
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Display a portrait drawing (typically called from scripts)
def setPortrait(portraitNum)
  word srcData
  byte cx, cy

  flipToPage1()
  
  // We're going to switch windows. Save the cursor pos in the text window.
  cx = ^cursh
  cy = ^cursv

  // Now clear out the map area
  setMapWindow()
  clearWindow()

  // Restore the cursor position
  setWindow2()
  ^cursh = cx
  ^cursv = cy

  // Load the portrait image and display it
  srcData = loader(QUEUE_LOAD, AUX_MEM, portraitNum<<8 | RES_TYPE_PORTRAIT)
  loader(FINISH_LOAD, MAIN_MEM, 0) // 0 = close

  if mapIs3D
    blitPortrait(srcData, $2182)  // start at 3rd text line
  else
    blitPortrait(srcData, $2202)  // start at 4th text line
  fin

  needRender = FALSE  // suppress display of map for this frame

  loader(FREE_MEMORY, AUX_MEM, srcData)
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Clear the displayed portrait drawing
def clrPortrait()
  render()
  needRender = FALSE
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Test out portrait drawing
def testPortrait()
  setPortrait(portraitNum)
  portraitNum = portraitNum + 1
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set up the command table for 3D mode
def initCmds()

  // Clear the command table
  byte i
  for i = 0 to 63
    cmdTbl[i] = 0
  next

  // Commands common to both 2D and 3D
  initCmd('T', @kbdTeleport)
  initCmd('P', @showPos)
  initCmd('/', @testPortrait)

  // Commands handled differently in 3D vs 2D
  if mapIs3D
    initCmd('W', @moveForward)
    initCmd('A', @rotateLeft)
    initCmd('D', @rotateRight)
    initCmd('S', @moveBackward)
    initCmd('X', @moveBackward)
    initCmd('Z', @strafeLeft)
    initCmd('C', @strafeRight)

    initCmd('I', @moveForward)
    initCmd('J', @rotateLeft)
    initCmd('L', @rotateRight)
    initCmd('K', @moveBackward)
    initCmd(',', @moveBackward)
    initCmd('M', @strafeLeft)
    initCmd('.', @strafeRight)

    initCmd('Y', @nextSky)
    initCmd('G', @nextGround)
  else
    initCmd('W', @moveNorth)
    initCmd('D', @moveEast)
    initCmd('S', @moveSouth)
    initCmd('X', @moveSouth)
    initCmd('A', @moveWest)

    initCmd('I', @moveNorth)
    initCmd('J', @moveWest)
    initCmd('L', @moveEast)
    initCmd('K', @moveSouth)
    initCmd(',', @moveSouth)
  fin
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Load and display the title screen.
def loadTitle()
  puts("Loading Lawless Legends.\n")

  // Load the title screen
  loader(SET_MEM_TARGET, MAIN_MEM, $2000)
  loader(QUEUE_LOAD,     MAIN_MEM, 1<<8 | RES_TYPE_SCREEN)  // title screen is fixed at #1
  loader(LOCK_MEMORY,    MAIN_MEM, $2000)
  loader(FINISH_LOAD, MAIN_MEM, 1) // 1 = keep open
  frameLoaded = 1
  ^$c050
  ^$c057
  ^$c054
  ^$c052
  // Hack for real (not emulated) IIc: sometimes displays only lo-bit graphics
  // unless we do this. *HUGE* thanks to Brendan Robert for the fix!
  ^$C07E=0   // disable double-hi-res
  ^$C05F     // disable double-hi-res
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Set vectors so that scripts in PLASMA can call back to do things with this engine.
def setCallbacks()

  // $300
  callbacks.0 = $4c
  callbacks:1 = @setScriptInfo

  // $303
  callbacks.3 = $4c
  callbacks:4 = @pushAuxStr

  // $306
  callbacks.6 = $4c
  callbacks:7 = @scriptDisplayStr

  // $309
  callbacks.9 = $4c
  callbacks:10 = @getYN

  // $30C
  callbacks.12 = $4c
  callbacks:13 = @queue_setMap

  // $30F
  callbacks.15 = $4c
  callbacks:16 = @setSky

  // $312
  callbacks.18 = $4c
  callbacks:19 = @setGround

  // $315
  callbacks.21 = $4c
  callbacks:22 = @queue_teleport

  // $318
  callbacks.24 = $4c
  callbacks:25 = @setPortrait

  // $31B
  callbacks.27 = $4c
  callbacks:28 = @clrPortrait

  // $31E
  callbacks.30 = $4c
  callbacks:31 = @moveBackward
end

///////////////////////////////////////////////////////////////////////////////////////////////////
// Main code.
//
loadTitle()
setCallbacks()
mapIs3D = OVERMAP_IS_3D
mapNum = OVERMAP_NUM
initMap(6, 123, 12)  // per Seth. Need to have this in a script in the future
//initMap(4, 4, 0)
checkScripts()
kbdLoop()

done