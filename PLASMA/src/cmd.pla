const iobuffer    = $0800
const databuff    = $0C00
const MOD_ADDR    = $1000
byte version[]    = "PLASMA VERSION 0.9"
byte errorstr[]   = "ERROR: $"
byte okstr[]      = "OK"
byte heaperr[]    = "ERR: HEAP/FRAME COLLISION.\n"
byte prefix[32]   = ""
word heap         = $6000
byte modtbl[256]
word lastmod      = @modtbl
byte symtbl[1024]
word lastsym      = @symtbl
byte deftbl[2048]
word lastdef      = @deftbl
byte perr
word cmdptr
;
; Utility functions
;
asm equates
;*
;* BANK SWITCHED MEM
;*
LCRDEN 	=	$C080
LCWTEN	=	$C081
ROMEN	=	$C082
LCRWEN 	=	$C083
LCBNK2	=	$00
LCBNK1	=	$08
	!SOURCE	"plvm02zp.inc"
;*
;* ASM VARIABLES
;*
ESP	!BYTE	0
end
;
; CALL PRODOS
; SYSCALL(CMD, PARAMS)
;
asm prodos
	LDA	ESTKL,X
	LDY	ESTKH,X
	STA	PARAMS
	STY	PARAMS+1
	INX
	LDA	ESTKL,X
	STA	CMD
	STX	ESP
	JSR	$BF00
CMD:	!BYTE	00
PARAMS:	!WORD	0000
	LDX	ESP
	STA	ESTKL,X
	LDY    	#$00
	STY	ESTKH,X
	RTS
end
;
; CALL LOADED SYSTEM PROGRAM
;
asm exec
	LDA	#$00
	STA	IFPL
	LDA	#$BF
	STA	IFPH
	LDX	#$FF
	TXS
	LDX	#ESTKSZ/2
	BIT	ROMEN
	JMP	$2000
end
;
; EXIT
;
asm reboot
	BIT	ROMEN
	LDA	#$00
	STA	$3F4		; INVALIDATE POWER-UP BYTE
	JMP	($FFFC)		; RESET
end
;
; SET MEMORY TO 0
; MEMCLR(ADDR, SIZE)
;
asm memclr
	LDY	#$00
	LDA 	ESTKL+1,X
	STA 	DSTL
	LDA 	ESTKH+1,X
	STA 	DSTH
	INC	ESTKL,X
	INC 	ESTKH,X
	TYA
SETMLP 	DEC 	ESTKL,X
	BNE	+
	DEC	ESTKH,X
	BEQ	++
+	STA	(DST),Y
	INY
	BNE	SETMLP
	INC	DSTH
	BNE	SETMLP
++	INX
	RTS
end
;
; COPY MEMORY
; MEMCPY(DSTADDR, SRCADDR, SIZE)
;
asm memcpy
	LDY	#$00
	LDA	ESTKL,X
	BNE 	+
	LDA	ESTKH,X
	BEQ	MEMEXIT
+	LDA	ESTKL+2,X
	STA 	DSTL
	LDA	ESTKH+2,X
	STA 	DSTH
	LDA	ESTKL+1,X
	STA 	SRCL
	LDA	ESTKH+1,X
	STA 	SRCH
	CMP	DSTH
	BCC	REVCPY
	BNE	FORCPY
	LDA 	SRCL
	CMP	DSTL
	BCS	FORCPY
REVCPY				; REVERSE DIRECTION COPY
;	CLC
	LDA 	ESTKL,X
	ADC	DSTL
	STA	DSTL
	LDA	ESTKH,X
	ADC	DSTH
	STA	DSTH
	CLC
	LDA 	ESTKL,X
	ADC	SRCL
	STA	SRCL
	LDA	ESTKH,X
	ADC	SRCH
	STA	SRCH
	INC 	ESTKH,X
REVCPYLP
	LDA	DSTL
	BNE	+
	DEC	DSTH
+	DEC	DSTL
	LDA	SRCL
	BNE	+
	DEC	SRCH
+	DEC	SRCL
	LDA	(SRC),Y
	STA	(DST),Y
	DEC 	ESTKL,X
	BNE	REVCPYLP
	DEC	ESTKH,X
	BNE	REVCPYLP
	BEQ	MEMEXIT
FORCPY	INC 	ESTKH,X
FORCPYLP
	LDA	(SRC),Y
	STA	(DST),Y
	INC	DSTL
	BNE	+
	INC	DSTH
+	INC	SRCL
	BNE	+
	INC	SRCH
+	DEC 	ESTKL,X
	BNE	FORCPYLP
	DEC	ESTKH,X
	BNE	FORCPYLP
MEMEXIT	INX
	INX
	RTS
end
;
; CHAR OUT
; COUT(CHAR)
;
asm cout
	LDA	ESTKL,X
	ORA 	#$80
	BIT	ROMEN
	JSR	$FDED
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; CHAR IN
; RDKEY()
;
asm cin
	BIT	ROMEN
	STX	ESP
	JSR     $FD0C
	LDX	ESP
	DEX
	STA     ESTKL,X
	LDY	#$00
	STY     ESTKH,X
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; PRINT STRING
; PRSTR(STR)
;
asm prstr
	LDY	#$00
	LDA     ESTKL,X
	STA     SRCL
	LDA     ESTKH,X
	STA     SRCH
	BIT	ROMEN
	LDA     (SRC),Y
	STA     ESTKL,X
	BEQ     +
-	INY
	LDA	(SRC),Y
	ORA	#$80
	JSR	$FDED
	TYA
	CMP	ESTKL,X
	BNE	-
+	BIT	LCRDEN+LCBNK2
	RTS
end
;
; PRINT BYTE
;
asm prbyte
	LDA	ESTKL,X
	STX     ESP
	BIT	ROMEN
	JSR	$FDDA
	LDX     ESP
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; PRINT WORD
;
asm prword
	LDA	ESTKH,X
	TAY
	LDA	ESTKL,X
	STX     ESP
	TAX
	TYA
	BIT	ROMEN
	JSR	$F941
	LDX     ESP
	BIT	LCRDEN+LCBNK2
	RTS
end
;
; READ STRING
; STR = RDSTR(PROMPTCHAR)
;
asm rdstr
	LDA     ESTKL,X
	STA     $33
	STX     ESP
	BIT	ROMEN
	JSR     $FD6A
	STX     $01FF
-	LDA	$01FF,X
	AND	#$7F
	STA	$01FF,X
	DEX
	BPL	-
	LDX     ESP
	LDA     #$FF
	STA     ESTKL,X
	LDA     #$01
	STA     ESTKH,X
	BIT	LCRDEN+LCBNK2
	RTS
end
asm toupper
	LDA     ESTKL,X
	CMP     #'a'
	BCC     +
	CMP     #'z'+1
	BCS     +
	SEC
	SBC     #$20
	STA     ESTKL,X
+	RTS
end
asm uword_isge
	STY	IPY
	LDY	#$00
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
asm uword_isle
	STY	IPY
	LDY	#$00
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	DEY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
asm uword_isgt
	STY	IPY
	LDY	#$FF
	LDA	ESTKL,X
	CMP	ESTKL+1,X
	LDA	ESTKH,X
	SBC	ESTKH+1,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
asm uword_islt
	STY	IPY
	LDY	#$FF
	LDA	ESTKL+1,X
	CMP	ESTKL,X
	LDA	ESTKH+1,X
	SBC	ESTKH,X
+ 	BCC	+
	INY
+ 	STY	ESTKL+1,X
	STY	ESTKH+1,X
	INX
	LDY	IPY
	RTS
end
def crout
    cout($0D)
end
;
; ProDOS routines
;
def getpfx(path)
    byte params[3]

    ^path    = 0
    params.0 = 1
    params:1 = path
    perr     = prodos($C7, @params)
    return path
end
def setpfx(path)
    byte params[3]

    params.0 = 1
    params:1 = path
    perr     = prodos($C6, @params)
    return path
end
def online
    byte params[4]

    params.0 = 2
    params.1 = 0
    params:2 = databuff
    perr     = prodos($C5, @params)
    return databuff
end
def open(path, buff)
    byte params[6]

    params.0 = 3
    params:1 = path
    params:3 = buff
    params.5 = 0
    perr     = prodos($C8, @params)
    return params.5
end
def close(refnum)
    byte params[2]

    params.0 = 1
    params.1 = refnum
    perr     = prodos($CC, @params)
    return perr
end
def read(refnum, buff, len)
    byte params[8]

    params.0 = 4
    params.1 = refnum
    params:2 = buff
    params:4 = len
    params:6 = 0
    perr     = prodos($CA, @params)
    return params:6
end

;
; Utility routines.
; 
; A DCI string is one that has the high bit set for every character except the last.
; More efficient than C or Pascal strings.
;
def dcitos(dci, str)
    byte len
    len = 0
    repeat
        str.[len] = dci.[len] & $7F
        len = len + 1
    until len > 15 or !(dci.[len - 1] & $80)
    str.[len] = 0
    return len
end
def stodci(str, dci)
    byte len
    len = 0
    while len < 16 and str.[len]
        dci.[len] = toupper(str.[len]) | $80
        len = len + 1
    loop
    dci.[len - 1] = dci.[len - 1] & $7F;
    return len;
end
;
; Heap routines.
;
def avail_heap
    byte fp
    return @fp - heap
end
def alloc_heap(size)
    word addr
    addr = heap
    heap = heap + size
;    if heap >= @addr
;        puts(@heaperr)
;        exit(1)
;    fin
    return addr
end
def free_heap(size)
    heap = heap - size;
    return @size - heap;
end
def mark_heap
    return heap;
end
def release_heap(newheap)
    heap = newheap;
    return @newheap - heap;
end
;def avail_xheap(void)
;    return 0xC000 - xheap;
;end
;def alloc_xheap(int size)
;    uword addr = xheap;
;    xheap += size;
;    if (xheap >= 0xC000)
;    {
;        printf("Error: xheap extinguished.\n");
;        exit (1);
;    }
;    return addr;
;end
;def free_xheap(int size)
;    xheap -= size;
;    return 0xC000 - heap;
;end
;def mark_xheap(void)
;    return xheap;
;end
;def release_xheap(uword newxheap)
;    xheap = newxheap;
;    return 0xC000 - xheap;
;end
;
; Copy from data mem to code mem.
;
;def xmemcpy(uword src, uword dst, uword size)
;    while (size--)
;        mem_code[dst + size] = mem_data[src + size]; 
;end
;
; Copy from code mem to data mem.
;
;def memxcpy(uword src, uword dst, uword size)
;    while (size--)
;        mem_data[dst + size] = mem_code[src + size]; 
;end
;
; DCI table routines,
;
def dump_tbl(tbl)
    byte len
    word entbl
    while ^tbl
        len = 0
        while ^tbl & $80
            cout(^tbl & $7F)
            tbl = tbl + 1
            len = len + 1
        loop
        cout(^tbl)
        tbl = tbl + 1
        cout(':')
        while len < 15
            cout(' ')
            len = len + 1
        loop
        cout('$')
        prbyte((tbl).1)
        prbyte((tbl).0)
        tbl = tbl + 2
    loop
end
def lookup_tbl(dci, tbl)
    byte str[20]
    word match, entry
    entry = tbl
    while ^entry
        match = dci
        while ^entry == ^match
            if !(^entry & $80)
                return (entry):1
            fin
            entry = entry + 1
            match = match + 1
        loop
        while ^entry & $80
            entry = entry + 1
        loop
        entry = entry + 2
    loop
    return 0
end
def add_tbl(dci, val, last)
    while ^dci & $80
        ^(*last) = ^dci
        *last = *last + 1
        dci   = dci + 1
    loop
    ^(*last) = ^dci
    *last = *last + 1
    dci   = dci + 1
    ^(*last) = val
    *last = *last + 2
end
;
; Symbol table routines.
;
def dump_sym
    ;printf("\nSystem Symbol Table:\n");
    dump_tbl(symtbl)
end
def lookup_sym(sym)
    return lookup_tbl(sym, symtbl)
end
def add_sym(sym, addr)
    return add_tbl(sym, addr, @lastsym);
end
;
; Module routines.
;
def dump_mod
    ;printf("\nSystem Module Table:\n");
    dump_tbl(modtbl)
end
def lookup_mod(mod)
    return lookup_tbl(mod, modtbl)
end
def add_mod(mod, addr)
    return add_tbl(mod, addr, @lastmod)
end
def defcall_add(bank, addr)
    (lastdef).0 = $20 ; JSR $03D6
    (lastdef):1 = $03D6
    (lastdef).3 = bank
    (lastdef):4 = addr
    lastdef = lastdef + 6
end
def def_lookup(cdd, defaddr)
    word i
    i = 0
    while (cdd).[i] == $02
        if (cdd):[i + 1] == defaddr)
            return cdd + i
        fin
        i = i + 4
    loop
    return 0
end
def extern_lookup(esd, index)
    word sym
    byte str[17]
    while ^esd
        sym = esd;
        esd = esd + dcitos(esd, str)
        if (esd).0 & $10 and (esd).1 == index
            return lookup_sym(sym)
        fin
        esd = esd + 3
    loop
    return 0
end
def load_mod(mod)
    word refnum, len, size,modend, bytecode, fixup, addr, init, modaddr, modfix
    word moddep, rld, esd, cdd, sym;
    byte header[128]
    byte filename[32]
    byte str[17]

    init = 0
    modaddr = mark_heap
    dcitos(mod, filename)
    ;printf("Load module %s\n", filename)
    refnum = open(filename)
    if refnum > 0
        len = read(refnum, @header, 128)
        if len > 4 and header:2 == $DA7E ; DAVE
            ;
            ; This is a relocatable bytecode module.
            ;
            bytecode = header:4
            init     = header:6
            moddep   = @header + 8
            if ^moddep
                ;
                ; Load module dependencies.
                ;
                close(refnum)
                while ^moddep
                    if lookup_mod(moddep) == 0
                        load_mod(moddep)
                    fin
                    moddep = moddep + dcitos(moddep, str)
                loop
                modaddr = mark_heap
                refnum  = open(filename)
                len     = read(refnum, modaddr, 128)
            fin
        else
            memcpy(modaddr, header, len)
        fin
        addr = modaddr + len;
        repeat
            len  = read(refnum, addr, 4096)
            addr = addr + len
        until len > 0
        close(refnum)
        size = addr - modaddr
        len      = *modaddr
        modend   = modaddr  + len
        modfix   = modaddr  - MOD_ADDR
        bytecode = bytecode + modfix
        rld      = modaddr  + len ; Re-Locatable Directory
        cdd      = rld            ; Code Definition Directory
        esd      = rld            ; Extern+Entry Symbol Directory
        while ^esd <> $00 ; Scan to end of RLD
            esd = esd + 4
	loop
        esd = esd + 1
        ;if show_state
            ;
            ; Dump different parts of module.
            ;
            ;printf("Module size: %d\n", size);
            ;printf("Module code+data size: %d\n", len);
            ;printf("Module magic: $%04X\n", magic);
            ;printf("Module bytecode: $%04X\n", bytecode);
            ;printf("Module init: $%04X\n", init);
        ;fin
        ;
        ; Print out the Re-Location Dictionary.
        ;
        ;if show_state
            ;printf("\nRe-Location Dictionary:\n")
        ;fin
        while ^rld
            if ^rld == $02
                ;if show_state prstr("\tDEF         CODE")
                (rld):1 = (rld):1 + modfix
                modend = rld + 4
            else
                addr = (rld):1 + modfix
                if (rld).0 & $80
                    fixup = *addr
                else
                    fixup = ^addr
                fin
                if (^rld & $10)
                    ;if show_state printf("\tEXTERN[$%02X] ", rld[3]);
                    fixup = fixup + extern_lookup(esd, rld[3]);
                else
                    ;if (show_state) printf("\tINTERN      ")
                    fixup = fixup + modfix
                    if uword_isge(fixup, bytecode)
                        ;
                        ; Replace with call def dictionary.
                        ;
                        fixup = def_lookup(cdd, fixup)
                    fin
                fin
                if ^rld & $80
                    ;if show_state printf("WORD")
                    *addr = fixup
                else
                    ;if show_state printf("BYTE")
                    ^addr = fixup
                fin
                
            fin
            ;if show_state printf("@$%04X\n", addr)
            rld = rld + 4;
        loop
        ;if show_state printf("\nExternal/Entry Symbol Directory:\n")
        while ^esd
            sym = esd
            esd = esd + dcitos(esd, str)
            if ^esd & $10
                ;if show_state printf("\tIMPORT %s[$%02X]\n", string, esd[1])
            elsif ^esd & $08
                addr = (esd):1 + modfix
                ;if show_state printf("\tEXPORT %s@$%04X\n", string, addr)
                if uword_isge(addr, bytecode)
                    addr = def_lookup(cdd, addr)
                fin
                add_sym(sym, addr)
            fin
            esd = esd + 3
        loop
    else
        ;printf("Error: Unable to load module %s\n", filename);
        return -1
    fin
    ;
    ; Reserve heap space for relocated module.
    ;
    alloc_heap(modend - modaddr)
    ;
    ; Call init routine.
    ;
    if init
    	return (init + modfix)()
    fin
    return 0
end
;
; Command mode
;
def volumes
    word strbuf
    byte i

    strbuf = online()
    for i = 0 to 15
        ^strbuf = ^strbuf & $0F
	if ^strbuf
	    cout('/')
	    prstr(strbuf)
	    crout()
	fin
	strbuf = strbuf + 16
    next
end
def catalog(optpath)
    byte path[64]
    byte refnum
    byte firstblk
    byte entrylen, entriesblk
    byte i, type, len
    word entry, filecnt

    if ^optpath
        memcpy(@path, optpath, ^optpath + 1)
    else
        getpfx(@path)
        prstr(@path)
        crout()
    fin
    refnum = open(@path, iobuffer);
    if perr
        return perr
    fin
    firstblk = 1
    repeat
        if read(refnum, databuff, 512) == 512
            entry = databuff + 4
            if firstblk
                entrylen   = databuff.$23
                entriesblk = databuff.$24
                filecnt    = databuff:$25
                entry      = entry + entrylen
            fin
            for i = firstblk to entriesblk
                type = ^entry
                if type <> 0
                    len = type & $0F
                    ^entry = len
                    prstr(entry)
                    if type & $F0 == $D0 ; Is it a directory?
                        cout('/')
                        len = len + 1
		    elsif (entry).$10 == $FF
		        cout('*')
			len = len + 1
                    fin
                    for len = 19 - len downto 0
                        cout(' ')
                    next
                    filecnt = filecnt - 1
                fin
                entry = entry + entrylen
            next
            firstblk = 0
        else
            filecnt = 0
        fin
    until filecnt == 0
    close(refnum)
    crout()
    return 0
end
def stripchars(strptr)
    while ^strptr and ^(strptr + 1) <> ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
	return ^strptr
end
def stripspaces(strptr)
	while ^strptr and ^(strptr + ^strptr) <= ' '
        ^strptr = ^strptr - 1
    loop
    while ^strptr and ^(strptr + 1) <= ' '
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    loop
end
def striptrail(strptr)
    byte i

    for i = 1 to ^strptr
        if (strptr)[i] == ' '
	    ^strptr = i - 1
	    return
	fin
    next
end
def parsecmd(strptr)
    byte cmd

    cmd = 0
    stripspaces(strptr)
    if ^strptr
        cmd = ^(strptr + 1)
        memcpy(strptr + 1, strptr + 2, ^strptr)
        ^strptr = ^strptr - 1
    fin
    stripspaces(strptr)
    return cmd
end
def resetmemfiles
    ;
    ; Close all files
    ;
    ^$BFD8 = 0
    close(0)
    ;
    ; Set memory bitmap
    ;
    memclr($BF58, 24)
    ^$BF58 = $CF
    ^$BF6F = $01
end
def execsys(sysfile)
    byte refnum
    word len

    if ^sysfile
        memcpy($280, sysfile, ^sysfile + 1)
	striptrail(sysfile)
	refnum = open(sysfile, iobuffer)
	if refnum
	    len = read(refnum, $2000, $FFFF)
	    resetmemfiles()
	    if len
	        memcpy(sysfile, $280, ^$280 + 1)
		if stripchars(sysfile) and ^$2000 == $4C and *$2003 == $EEEE
		    stripspaces(sysfile)
		    if ^$2006 <= ^sysfile
		        memcpy($2006, sysfile, ^sysfile + 1)
		    fin
		fin
	        striptrail($280)
		exec()
	    fin
	fin
    fin
end

def prucomp(a, b)
    if uword_isgt(a, b)
        prword(a)
        cout('>')
        prword(b)
	crout
    fin
    if uword_isge(a, b)
        prword(a)
        cout('>')
        cout('=')
        prword(b)
	crout
    fin
    if uword_islt(a, b)
        prword(a)
        cout('<')
        prword(b)
	crout
    fin
    if uword_isle(a, b)
        prword(a)
        cout('<')
        cout('=')
        prword(b)
	crout
    fin
end

resetmemfiles()
prstr(@version)
crout()
prucomp($1, $2)
prucomp($2, $1)
prucomp($100, $200)
prucomp($200, $100)
prucomp($9000, $A000)
prucomp($A000, $9000)
prucomp($E000, $E000)
prucomp($E001, $E000)
prucomp($E000, $E001)
prucomp($FFFF, $FFFE)
prucomp($FFFE, $FFFF)
while 1
    prstr(getpfx(@prefix))
    cmdptr = rdstr($BA)
    when toupper(parsecmd(cmdptr))
        is 'Q'
	    reboot()
	is 'C'
	    catalog(cmdptr)
	is 'P'
	    setpfx(cmdptr)
	is 'V'
	    volumes();
	is '-'
	    execsys(cmdptr)
	    perr = $46
    wend
    if perr
        prstr(@errorstr)
	prbyte(perr)
    else
        prstr(@okstr)
    fin
    crout()
loop
done